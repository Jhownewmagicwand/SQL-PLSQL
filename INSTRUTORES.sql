CREATE TABLE INSTRUTORES
(COD_INSTRUTOR NUMBER(03)
CONSTRAINT INSTRUTORES_PK PRIMARY KEY NOT NULL,
NOME_INSTRUTOR VARCHAR2(30)
CONSTRAINT INSTRUTORES_NOME_NU NOT NULL,
TEL_INSTRUTOR VARCHAR2(10),
ADMISSAO DATE DEFAULT SYSDATE);

SELECT * FROM INSTRUTORES;
SELECT * FROM CURSOS;
SELECT * FROM ALUNOS;
SELECT * FROM HISTORICO;
SELECT * FROM TURMAS;

ALTER TABLE INSTRUTORES
ADD(PREÇO_HORA_INSTRUTOR VARCHAR2(40));

ALTER TABLE INSTRUTORES
ADD (ENDEREÇO VARCHAR2(60));

INSERT INTO INSTRUTORES
(COD_INSTRUTOR,NOME_INSTRUTOR,TEL_INSTRUTOR,PREÇO_HORA_INSTRUTOR)
VALUES
(1,'JHONATAN',955555555,0);

INSERT INTO INSTRUTORES
(COD_INSTRUTOR,NOME_INSTRUTOR,TEL_INSTRUTOR,PREÇO_HORA_INSTRUTOR)
VALUES
(2,'LUCAS',944444444,4);

INSERT INTO INSTRUTORES
(COD_INSTRUTOR,NOME_INSTRUTOR,TEL_INSTRUTOR,PREÇO_HORA_INSTRUTOR)
VALUES
(3,'GILSON',912121212,7);

SELECT * FROM INSTRUTORES;

DELETE  FROM  INSTRUTORES
WHERE COD_INSTRUTOR = '';
OR NOME_INSTRUTOR = 'JHONATAN'
OR TEL_INSTRUTOR = '955555555'
OR PREÇO_HORA_INSTRUTOR = 10;
'APAGAR INFORMAÇOES DENTRO DOS CAMPOS'

CREATE TABLE FAIXAS
(COD_FAIXAS NUMBER(02)
CONSTRAINT COD_FAIXAS_PK PRIMARY KEY NOT NULL,
DESCRIÇAO VARCHAR2(10),
MINIMO VARCHAR(10),
MAXIMO FLOAT(10));

SELECT * FROM FAIXAS;

DROP TABLE FAIXAS CASCADE CONSTRAINT;
SELECT * FROM FAIXAS;
DROP TABLE FAIXAS;

INSERT INTO FAIXAS
(COD_FAIXAS,DESCRIÇAO,MINIMO,MAXIMO)
VALUES (0,'BARATO',0,3.99);

INSERT INTO FAIXAS
(COD_FAIXAS,DESCRIÇAO,MINIMO,MAXIMO)
VALUES (4,'MEDIO',4,6.99);

INSERT INTO FAIXAS
(COD_FAIXAS,DESCRIÇAO,MINIMO,MAXIMO)
VALUES (7,'CARO',7,10.00);

DELETE FROM FAIXAS
WHERE COD_FAIXAS = '0';


CREATE TABLE ALUNOS
(MATRICULA NUMBER(03)
CONSTRAINT ALUNOS_PK PRIMARY KEY NOT NULL,
NOME_ALUNO VARCHAR2(30)
CONSTRAINT ALUNOS_NOME_NU NOT NULL,
TEL_ALUNO VARCHAR2(10),
ENDEREÇO_ALUNO VARCHAR2(30),
CIDADE_ALUNO VARCHAR2(20) DEFAULT 'RIO DE JANEIRO',
UF CHAR(02) DEFAULT 'RJ' CONSTRAINT ALUNOS_UF_CH CHECK (UF IN ('SP','MG','RJ','ES')));

INSERT INTO ALUNOS
(COD_CURSO)
VALUES
(1);

UPDATE ALUNOS
SET 
"MATRICULA" = '3'    
WHERE "COD_CURSO" = 3;

ALTER TABLE TURMAS
ADD (COD_FAIXAS CONSTRAINT COD_FAIXA_FK REFERENCES FAIXAS(COD_FAIXAS));

DROP TABLE ALUNOS CASCADE CONSTRAINT;
SELECT * FROM ALUNOS;
WHERE NOME_ALUNO;

INSERT INTO ALUNOS
(MATRICULA, NOME_ALUNO,TEL_ALUNO,COD_CURSO)
VALUES
(1,'ALVARO LEPUS',977777777,1);

INSERT INTO ALUNOS
(MATRICULA, NOME_ALUNO,TEL_ALUNO,COD_CURSO)
VALUES
(2,'JOSE CARLOS',978787878,2);

INSERT INTO ALUNOS
(MATRICULA, NOME_ALUNO,TEL_ALUNO,COD_CURSO)
VALUES
(3,'ALINE DIAS',901010101,3);


CREATE TABLE TURMAS
(COD_TURMA NUMBER(03)
CONSTRAINT TURMAS_PK PRIMARY KEY NOT NULL,
COD_CURSO 
CONSTRAINT TURMAS_CURSO_FK REFERENCES CURSOS(COD_CURSO),
COD_INSTRUTOR
CONSTRAINT TURMAS_INSTRUTOR_FK REFERENCES INSTRUTORES(COD_INSTRUTOR),
SALA NUMBER(02));



DELETE  FROM  TURMAS
WHERE 
COD_TURMA = '1'
OR COD_CURSO = '1'
OR COD_INSTRUTOR = '1'
OR SALA  = '5';


ALTER TABLE TURMAS
ADD (COD_FAIXAS CONSTRAINT COD_FAIXAS_FK REFERENCES FAIXAS(COD_FAIXAS));
'ADICIONAR UMA CONSTRAINT EM UMA TABELA JÁ CRIADA'

ALTER TABLE TURMAS
DISABLE CONSTRAINT DESCRIÇAO_FAIXAS_FK;

ALTER TABLE TURMAS
DROP CONSTRAINT DESCRIÇAO_FAIXAS_FK;

SELECT * FROM TURMAS;

DROP TABLE TURMAS CASCADE CONSTRAINT;

UPDATE TURMAS
SET 
COD_CURSO = '2',
COD_INSTRUTOR = '2',
SALA = '10',
COD_FAIXAS = '2',
MATRICULA = '2'    
WHERE COD_TURMA = 2; 

INSERT INTO TURMAS
(COD_TURMA,COD_CURSO,COD_INSTRUTOR, SALA, COD_FAIXAS,MATRICULA)
VALUES
(1,1,1,10,0,1);

INSERT INTO TURMAS
(COD_TURMA,COD_CURSO,COD_INSTRUTOR, SALA, COD_FAIXAS,MATRICULA)
VALUES
(2,1,2,5,4,2);

INSERT INTO TURMAS
(COD_TURMA,COD_CURSO,COD_INSTRUTOR, SALA, COD_FAIXAS,MATRICULA)
VALUES
(3,3,3,11,7,3);

SELECT * FROM TURMAS;

DELETE FROM TURMAS
WHERE COD_TURMA = '2';
OR COD_CURSO = '2';

SELECT * FROM INSTRUTORES;

ALTER TABLE TURMAS
ADD CONSTRAINT TURMAS_CURSO_FK 
FOREIGN KEY(COD_CURSO)
REFERENCES CURSOS(COD_CURSO);

CREATE TABLE CURSOS
(COD_CURSO NUMBER(03)
CONSTRAINT CURSO_PK PRIMARY KEY NOT NULL,
COD_TURMA
CONSTRAINT CURSO_TURMAS_FK REFERENCES TURMAS(COD_TURMA), 
NOME_CURSO VARCHAR2(60)
CONSTRAINT CURSO_NOME_NU NOT NULL UNIQUE,
CARGA_HORARIA NUMBER(03),
PREÇO NUMBER(7,2) DEFAULT '0' );

SELECT NOME_ALUNOS FROM CURSOS;
SELECT * FROM CURSOS;



INSERT INTO CURSOS
(COD_CURSO,NOME_CURSO,CARGA_HORARIA,PREÇO,PRE_REQUISITO)
VALUES 
(1,'CURSO1LOGICA',32,800,'1');

INSERT INTO CURSOS
(COD_CURSO,NOME_CURSO,CARGA_HORARIA,PREÇO,PRE_REQUISITO)
VALUES 
(2,'CURSO2LOGICA',-1,90,'2');

INSERT INTO CURSOS
(COD_CURSO,NOME_CURSO,CARGA_HORARIA,PREÇO,PRE_REQUISITO)
VALUES 
(3,'CURSO3LOGICA',-2,91,'3');

DELETE FROM CURSOS
WHERE COD_CURSO = '3';
OR NOME_CURSO = 'CURSO2LOGICA'
OR CARGA_HORARIA = '-1'
OR PREÇO = '90';

DROP TABLE CURSOS CASCADE CONSTRAINT;




ALTER TABLE CURSOS 
ADD (PRE_REQUISITO NUMBER(03));
'ADICIONAR MAIS UM CAMPO EM UMA TABELA JÁ CRIADA'

ALTER TABLE INSTRUTORES
MODIFY (PRE_REQUISITO VARCHAR2(60));

ALTER TABLE TURMAS
DROP COLUMN COD_FAIXAS;
'APAGAR COLUNA DE UMA TABELA JÁ CRIADA' 

ALTER TABLE CURSOS
ADD CONSTRAINT CARGA_HORARIA_CH 
CHECK(CARGA_HORARIA >=32);

ALTER TABLE CURSOS
 RENAME COLUMN CARGA_HORARIA TO CONSTRAINT CARGA_HORARIA_CH;


ALTER TABLE CURSOS
DISABLE CONSTRAINT CARGA_HORARIA_CH;

ALTER TABLE CURSOS 
DROP CONSTRAINT CARGA_HORARIA_CH;

ALTER TABLE CURSOS
MODIFY CARGA_HORARIA


DELETE FROM CURSOS 
COD_CURSO,NOME_CURSO,CARGA_HORARIA,PREÇO,PRE_REQUISITO = 1,'INTRODUÇAO A LOGICA DE PROGRAMAÇAO',32,800;                                                                                                                                                                         


CREATE TABLE HISTORICO
(COD_TURMA
CONSTRAINT  HISTORICO_TURMA_FK
REFERENCES TURMAS (COD_TURMA),
MATRICULA 
CONSTRAINT HISTORICO_ALUNO_FK
REFERENCES ALUNOS(MATRICULA),
NOTA NUMBER (7,2),
COD_HIST NUMBER(03)
CONSTRAINT COD_HIST_PK PRIMARY KEY NOT NULL);

SELECT * FROM HISTORICO;

DROP TABLE HISTORICO CASCADE CONSTRAINT;

ALTER TABLE HISTORICO
ADD CONSTRAINT HISTORICO_NOTA_CH
CHECK(NOTA >=0 AND NOTA<= 10);

ALTER TABLE HISTORICO
DISABLE CONSTRAINT HISTORICO_NOTA_CH;
'CONSTRAINT'

ALTER TABLE HISTORICO
DROP CONSTRAINT HISTORICO_NOTA_CH;

INSERT INTO HISTORICO
VALUES
(1,1,7.5,1);
 

DROP TABLE CURSOS CASCADE CONSTRAINT;
DROP TABLE ALUNOS CASCADE CONSTRAINT;
'APAGAR TABELA JÁ TIRANDO OS CONTRAINTS'

SELECT * FROM HISTORICO;

SELECT * FROM CURSOS;

SELECT * FROM CAT;


SELECT * FROM INSTRUTORES;
SELECT NOME_CURSO, CARGA_HORARIA FROM CURSOS;
SELECT NOME_CURSO||' COM CARGA HORARIA: ' ||NVL(CARGA_HORARIA,0) FROM CURSOS;

SELECT NOME_CURSO, CARGA_HORARIA FROM CURSOS
ORDER BY CARGA_HORARIA DESC;

SELECT NOME_CURSO, CARGA_HORARIA FROM CURSOS
ORDER BY 2 DESC;

SELECT NOME_CURSO, CARGA_HORARIA FROM CURSOS
WHERE CARGA_HORARIA >30
ORDER BY CARGA_HORARIA DESC;

SELECT * FROM CURSOS
WHERE NOME_CURSO LIKE 'CURSO%'
OR NOME_CURSO LIKE 'CURSO%';
'COMEÇA COM O TEXTO'


SELECT * FROM CURSOS
WHERE NOME_CURSO LIKE '%LOGICA'
OR NOME_CURSO LIKE '%LOGICA';
'TERMINA COM O TEXTO'


SELECT * FROM CURSOS
WHERE NOME_CURSO LIKE 'CURSO1LOGICA'
OR NOME_CURSO LIKE 'CURSO2LOGICA';
'BUSCA O TEXTO EXATAMENTE COLOCADO'


SELECT * FROM CURSOS
WHERE NOME_CURSO LIKE '%1%'
OR NOME_CURSO LIKE '%2%';
'BUSCA O TEXTO QUE CONTEM NO CAMPO BUSCADO'

SELECT * FROM CURSOS
WHERE NOME_CURSO LIKE '_U%'
OR NOME_CURSO LIKE '_U%';
'BUSCA A SEGUNDA LETRA'


SELECT NOME_CURSO FROM CURSOS
WHERE NOME_CURSO LIKE '_URSO1LOGICA'
OR NOME_CURSO LIKE '_URSO2LOGICA';
'BUSCA O RESTO APÓS A PRIMEIRA LETRA'
'QUANDO O SELECT TEM UM CAMPO LISTADO, ELE SÓ PASSA A INFORMAÇÃO DO CAMPO'


SELECT * FROM CURSOS
WHERE NOME_CURSO LIKE 'C_A'
OR NOME_CURSO LIKE 'C_A';
'BUSCA A PRIMEIRA LETRA E ULTIMA LETRA PORÉM DEVE TER 1 LETRA NO MEIO DELA'

SELECT * FROM CURSOS
WHERE PRE_REQUISITO IS NULL;
'MOSTRA CAMPO COM CONTEÚDO NULO'

SELECT COD_TURMA, NOME_INSTRUTOR,SALA
FROM INSTRUTORES, TURMAS
WHERE INSTRUTORES.COD_INSTRUTOR = 
TURMAS.COD_INSTRUTOR;
'REUNE CAMPOS IGUAIS DE TABELAS DIFERENTES OU SEJA CHAVES PRIMARIAS E ESTRANGEIRAS'


SELECT T.COD_TURMA, I.NOME_INSTRUTOR, T.SALA
FROM INSTRUTORES I, TURMAS T
WHERE I.COD_INSTRUTOR = T.COD_INSTRUTOR;
'COM ALIAS'

SELECT COD_TURMA, NOME_CURSO, NOME_INSTRUTOR
FROM INSTRUTORES I , CURSOS C, TURMAS T
WHERE I.COD_INSTRUTOR = T.COD_INSTRUTOR
AND C.COD_CURSO = T.COD_CURSO;
'MAIS DE 2 TABELAS'
"________________________________________"
SELECT COD_TURMA, NOME_INSTRUTOR, SALA
FROM INSTRUTORES I , TURMAS T 
WHERE I.COD_INSTRUTOR = T.COD_INSTRUTOR(+)
ORDER BY 1;


SELECT COD_TURMA, NOME_INSTRUTOR, SALA
FROM INSTRUTORES I , TURMAS T 
WHERE I.COD_INSTRUTOR(+) = T.COD_INSTRUTOR
ORDER BY 1;
'ADICIONA MAIS UMA INFORMAÇÃO PARA A TABELA E MOSTRA OS QUE FALTAM'


SELECT NOME_CURSO, COD_TURMA
FROM CURSOS C, TURMAS T
WHERE T.COD_CURSO = C.COD_CURSO;

SELECT NOME_INSTRUTOR, COD_TURMA,DESCRIÇAO
FROM INSTRUTORES I, TURMAS T, FAIXAS F
WHERE I.COD_INSTRUTOR = T.COD_INSTRUTOR
AND I.PREÇO_HORA_INSTRUTOR BETWEEN F.MINIMO AND F.MAXIMO;
'REUNI CAMPOS DE TABELAS QUE NÃO TENHAM NADA EM COMUM'

SELECT P.NOME_CURSO CURSO,
C.NOME_CURSO "PRÉ-REQUISITO" 
FROM CURSOS C, CURSOS P
WHERE P.PRE_REQUISITO = C.COD_CURSO;
'QUANDO HOUVER DOIS CAMPOS EM UMA MESMA TABELA QUE SEJAM DO MESMO TIPO'

SELECT * FROM TURMAS;

SELECT NOME_ALUNO, COD_TURMA
FROM ALUNOS A, TURMAS T
WHERE A.MATRICULA = T.MATRICULA AND COD_TURMA <2;


SELECT NOME_ALUNO, NOME_CURSO
FROM ALUNOS A, CURSOS C
WHERE A.MATRICULA = C.COD_CURSO;

SELECT NOME_CURSO,LPAD(PREÇO,11,'*')CUSTO
FROM CURSOS
WHERE UPPER (NOME_CURSO) LIKE'C%'
OR UPPER(NOME_CURSO)LIKE 'C%';
'PREENCHE A ESQUERDA COM '*'ATE O TAMANHO DO VALOR EX:'800''

SELECT SYSDATE HOJE, NEXT_DAY(SYSDATE, 'SUNDAY')DOMINGO FROM DUAL;
'MOSTRA O DIA E HORARIO DE HOJE E DO PRÓXIMO DIA COLOCADO NO CASO DOMINGO)'

SELECT NOME_CURSO, PREÇO*1.33 PREÇO, FLOOR(1.33*PREÇO) BAIXO,
CEIL(1.33*PREÇO)ALTO 
FROM CURSOS
WHERE UPPER(NOME_CURSO)LIKE 'C%';
'MOSTRA O PREÇO MULTIPLICADO E O RETORNA UM VALOR MAIS PROXIMO = FLOOR, 
E ARREDONDA COM UM NUMERO A MAIS = CEIL E MOSTRA O NOME DO CURSO QUE COMECE COM C' 

SELECT TO_CHAR(SYSDATE,'DD-MM-YYYY HH24:MI')HOJE,
TO_CHAR(SYSDATE+28/24,'DD-MM-YYYY HH24:MI')"AMANHA + 4 HORAS" 
FROM DUAL;
'MOSTRA A DATA E HORA DE AGORA E DE AMANHA COM 4 HORAS A MAIS'

SELECT NOME_CURSO, TO_CHAR(PREÇO, '9,999.99')CUSTO FROM CURSOS;
'MOSTRA O NOME DO CURSO E O CUSTO COM OS '00' DO PREÇO)'

SELECT NOME_CURSO,
NVL(TO_CHAR(CARGA_HORARIA,99),'SEM CARGA HORARIA')CARGA_HORARIA
FROM CURSOS;
'MOSTRA O NOME DO CURSO E SUA CARGA HORARIA COM 2 DIGITOS, CASO NÃO HOUVER CARGA HORARIA
APARECERÁ 'SEM CARGA HORARIA''

SELECT * FROM INSTRUTORES
WHERE ADMISSAO>TO_DATE('1-JAN-98');
'MOSTRA A TABELA INSTRUTORES E DATA DE ADMISSAO DE JANEIRO DE 98 ATÉ O MOMENTO ATUAL'

SELECT * FROM INSTRUTORES
WHERE ADMISSAO>TO_DATE('1-1-1998','DD-MM-YYYY');
'MOSTRA A TABELA INSTRUTORES E DATA DE ADMISSAO COM DATA, MES E ANO DIFERENTE'

SELECT COUNT(CARGA_HORARIA)FROM CURSOS;
'MOSTRA O TOTAL DE LINHAS DE SELECIONADAS'

SELECT COUNT(*) FROM CURSOS;
'MOSTRA O TOTAL DE LINHAS DE SELECIONADAS MESMO NULO'

SELECT NOME_CURSO, SUM(PREÇO) ARRECADADO
FROM CURSOS C, TURMAS T, HISTORICO H 
WHERE C.COD_CURSO = T.COD_CURSO
AND T.COD_TURMA = H.COD_TURMA
GROUP BY NOME_CURSO
ORDER BY 2 DESC;
'MOSTRA O NOME DO CURSO E O VALOR ARRECADADO ATRÁVES DO CODIGO DE HISTORICO E TURMA PARA ACHAR O VALOR'

SELECT MATRICULA FROM ALUNOS
WHERE UPPER(MATRICULA) LIKE '%C%'
UNION
SELECT NOME_CURSO FROM CURSOS 
WHERE UPPER(NOME_CURSO)LIKE'%A%'
ORDER BY 1;

SELECT NOME_CURSO, SUM(PREÇO) ARRECADADO 
FROM CURSOS C, TURMAS T, HISTORICO H
WHERE C.COD_CURSO = T.COD_CURSO
AND T.COD_TURMA = H.COD_TURMA
GROUP BY NOME_CURSO
HAVING SUM(PREÇO)>100000
ORDER BY 2 DESC;
'MOSTRA O NOME DO CURSO E O CURSO OU COLUNA COM VALOR ARRECADADO MAIOR QUE 10000'

CREATE TABLE CURSOS_VELHOS
(COD_CURSOV NUMBER(03)
CONSTRAINT COD_CURSOV_PK PRIMARY KEY,
NOME_CURSOV VARCHAR2(60),
CARGA_HORARIAV NUMBER(03));

INSERT INTO CURSOS_VELHOS
(COD_CURSOV,NOME_CURSOV,CARGA_HORARIAV)
VALUES(1,'INFORMATICA',32);

INSERT INTO CURSOS_VELHOS
(COD_CURSOV,NOME_CURSOV,CARGA_HORARIAV)
VALUES(5,'CURSO1LOGICA',32);

SELECT NOME_CURSO, CARGA_HORARIA FROM CURSOS
WHERE UPPER(NOME_CURSO) LIKE '%C%'
UNION
SELECT NOME_CURSOV,CARGA_HORARIAV FROM CURSOS_VELHOS
WHERE UPPER(NOME_CURSOV)LIKE'%A%'
ORDER BY 1;
'CRIA UMA UNIAO DE TABELAS E MOSTRA CURSOS NOVOS E ANTIGOS SEM REPETIÇAO'

SELECT NOME_CURSO,CARGA_HORARIA FROM CURSOS
WHERE UPPER(NOME_CURSO) LIKE'%C%'
UNION ALL
SELECT NOME_CURSOV,CARGA_HORARIAV FROM CURSOS_VELHOS
WHERE UPPER(NOME_CURSOV) LIKE '%A%'
ORDER BY 1;
'CRIA UMA UNIAO DE TABELAS E MOSTRA CURSOS NOVOS E ANTIGOS COM REPETIÇAO'

SELECT NOME_CURSO,CARGA_HORARIA FROM CURSOS
WHERE UPPER(NOME_CURSO)LIKE '%C%'
INTERSECT
SELECT NOME_CURSOV,CARGA_HORARIAV FROM CURSOS_VELHOS
WHERE UPPER(NOME_CURSOV)LIKE '%C%'
ORDER BY 1;
'CRIA UMA UNIAO DE TABELAS E MOSTRA CURSOS EM COMUM'

SELECT NOME_CURSO,CARGA_HORARIA FROM CURSOS
WHERE UPPER(NOME_CURSO) LIKE '%C%'
MINUS
SELECT NOME_CURSOV, CARGA_HORARIAV FROM CURSOS_VELHOS
WHERE UPPER(NOME_CURSOV) LIKE '%C%'
ORDER BY 1;
'CRIA UMA UNIAO DE TABELAS E MOSTRA APENAS CURSOS QUE A PRIMEIRA TABELA TEM'
SELECT NOME_CURSOV,CARGA_HORARIAV FROM CURSOS_VELHOS
WHERE UPPER(NOME_CURSOV) LIKE '%C%'
MINUS
SELECT NOME_CURSO, CARGA_HORARIA FROM CURSOS
WHERE UPPER(NOME_CURSO) LIKE '%C%'
ORDER BY 1; 
"____________________________________________________________________________"
DESC USER_CONSTRAINTS;
SELECT TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_TYPE FROM USER_CONSTRAINTS
ORDER BY 1,2;

SELECT NOME_CURSO, SUM(PREÇO) ARRECADADO
FROM CURSOS
GROUP BY NOME_CURSO;

SELECT * FROM ALUNOS;

SELECT NOME_CURSO, COUNT(MATRICULA) ALUNOS
FROM CURSOS C, ALUNOS A
WHERE C.COD_CURSO = A.COD_CURSO
GROUP BY NOME_CURSO
ORDER BY 2 DESC;
'MOSTRA QUANTOS ALUNOS POR CURSO'

SELECT COD_TURMA, AVG(PREÇO) ARRECADADO
FROM TURMAS T, CURSOS C
WHERE C.COD_CURSO = T.COD_CURSO
GROUP BY COD_TURMA
ORDER BY 2 DESC;
'ARRECADAÇAO MEDIA POR TURMA'

SELECT * FROM TURMAS;

UPDATE CURSOS
SET PREÇO = PREÇO*1.1
WHERE UPPER(NOME_CURSO)LIKE 'C%';
'ATUALIZOU O PREÇO DOS CURSOS EM 10%'

DELETE HISTORICO
WHERE COD_TURMA = 10;
'ELIMINA A PEÇA DE CODIGO 10'

DELETE FROM TURMAS_CURSOS;
'ELIMINAÇAO FRUSTRADA POR CONSTRAINT(USAR DROP TABLE CURSOS CASCADE CONSTRAINT)'

TRNCATE TABLE CURSOS_VELHOS;
'DELETA TODAS AS LINHAS DA TABELA SEM POSSIBILIDADE DE VOLTA OU SEJA LIBERA ARMAZENAMENTO UTILIZADO PELA TABELA'

SELECT * FROM CURSOS;

SET TRANSACTION READ ONLY;
'SOMENTE LEITURA'

INSERT INTO INSTRUTORES
(COD_INSTRUTOR, NOME_INSTRUTOR)
VALUES
(11,'ARQUIMEDES ORACLITO');

COMMIT;
'PARA ACESSAR O BANCO É PRECISO EXECUTAR ESTE COMANDO E PARA EXECUTAR OS COMANDO(INSERT,DELETE,UPDATE)'

SET TRANSACTION READ WRITE;
'LEITURA E ESCREVER'

INSERT INTO INSTRUTORES
(COD_INSTRUTOR, NOME_INSTRUTOR)
VALUES
(12,'MARIO ALMILAN');

SELECT NOME_INSTRUTOR FROM INSTRUTORES;

ROLLBACK;
'DESCONSIDERA O COMANDO(INSERT,DELETE,UPDATE)'

SELECT NOME_INSTRUTOR FROM INSTRUTORES;

INSERT INTO INSTRUTORES
(COD_INSTRUTOR,NOME_INSTRUTOR)
VALUES
(12,'MARIO ALMILIAN');

SELECT NOME_INSTRUTOR FROM INSTRUTORES;

SAVEPOINT INCLUSAO_OK;
'SALVA UMA MARCA OU SEJA UM INSERT DENOMINADO 
E CASO QUEIRA DESCONSIDERAR ELE APENAS MANDAR UM ROLLBACK COM A MARCA'

INSERT INTO INSTRUTORES
(COD_INSTRUTOR,NOME_INSTRUTOR)
VALUES
(13,'NAIR MINTACA');

SELECT NOME_INSTRUTOR FROM INSTRUTORES;

ROLLBACK TO INCLUSAO_OK;
'MARCA DESCONSIDERADA'

SELECT NOME_INSTRUTOR FROM INSTRUTORES;

COMMIT; 

UPDATE CURSOS
SET PREÇO = PREÇO * 1.2
WHERE UPPER(NOME_CURSO)LIKE 'C%';

SELECT * FROM CURSOS;

ROLLBACK;

COMMIT


CREATE TABLE TESTE
(COD_TESTE NUMBER(03

CONSTRAINT COD_TESTE_PK PRIMARY KEY,
NADA VARCHAR2(30));

COMMIT;

INSERT INTO TESTE
(COD_TESTE,NADA)
VALUES
(1,'NADINHA');

COMMIT;
SELECT * FROM ALUNOS;
ROLLBACK;
SET TRANSACTION READ ONLY;
SET TRANSACTION READ WRITE;
DELETE FROM TESTE;

INSERT INTO ALUNOS
(MATRICULA,NOME_ALUNO,TEL_ALUNO)
VALUES
(8,'JOSE DIAS',971717171);

DELETE FROM ALUNOS
WHERE MATRICULA = 4;

SELECT * FROM ALUNOS;

CREATE INDEX TURMAS_COD_CURSO_IDX
ON TURMAS(COD_CURSO);
'CRIA UM INDICE PARA TURMAS OU SEJA MELHORIA DE ACESSO AS TABELAS'

CREATE INDEX ALUNOS_NOME_ALUNO_IDX
ON ALUNOS(UF ASC,NOME_ALUNO DESC);
'CRIA UM INDICE PARA ALUNOS COM UF ASC E NOME_ALUNO DESC'

SELECT * FROM ALUNOS;

SELECT INDEX_NAME FROM USER_INDEXES;
'VERIFICAR A EXISTENCIA DE INDICES, ORACLE CRIA AUTOMATICAMENTE INDICES DO TIPO UNIQUE 
QUANDO CRIADO CHAVES PRIMARIAS(INDEX TEM O MESMO NOME DA CHAVE PRIMARIA(MESMO NOME DA CONSTRAINT))'

SELECT INDEX_NAME,COLUMN_NAME,COLUMN_POSITION,COLUMN_LENGTH
FROM USER_IND_COLUMNS
WHERE TABLE_NAME = 'TURMAS';
'VERIFICAR A EXISTENCIA DE COLUNAS'

DROP INDEX TURMAS_COD_CURSO_IDX;
'ELIMINA UM INDICE(INDEX) CRIADO, ESSE COMANDO NAO ELIMINA INDICES CRIADO PELAS CONSTRAINTS'

CREATE VIEW ARRECADADO
AS
SELECT NOME_CURSO CURSO, T.COD_TURMA TURMAS, SUM(PREÇO)
ARRECADADO
FROM CURSOS C, TURMAS T, HISTORICO H
WHERE C.COD_CURSO = T.COD_CURSO
AND T.COD_TURMA = H.COD_TURMA
GROUP BY NOME_CURSO, T.COD_TURMA
HAVING SUM(PREÇO) > 0;
'CRIAÇAO DE UMA VIEW QUE MOSTRA O VALOR ARRECADADO ATRAVES DO COD DA TURMA E PUXANDO DO HISTORICO COM O NOME DO CURSO'    

SELECT * FROM ARRECADADO ORDER BY ARRECADADO DESC;
'VENDO A VIEW'

DESC ARRECADADO;

SELECT VIEW_NAME, TEXT_LENGTH, TEXT FROM USER_VIEWS;
'CONFIRMAÇAO DA EXISTENCIA DA VIEW'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
DROP VIEW ARRECADADO;
'DELETANDO A VIEW'

CREATE SEQUENCE ID_CURSO
INCREMENT BY 1
START WITH 11
MAXVALUE 999
NOCYCLE;
'CRIAÇAO DE UMA SEQUENCE(SEQUENCIAS) OU SEJA AUTO INCREMENTO'

SELECT SEQUENCE_NAME,INCREMENT_BY,MAX_VALUE,LAST_NUMBER
FROM USER_SEQUENCES;
'CONFIRMANDO A EXISTENCIA DE SEQUENCES'

INSERT INTO CURSOS(COD_CURSO,NOME_CURSO)
VALUES(ID_CURSO.NEXTVAL,'ORACLE:ADMINISTRAÇAO');
'INSERINDO UM AUTO INCREMENTO'

SELECT COD_CURSO,NOME_CURSO FROM CURSOS;
'MOSTRANDO A COLUNA COM O AUTO INCREMENTO)'

SELECT ID_CURSO.CURRVAL FROM DUAL;
'RETORNA O VALOR DA SEQUENCE'

DROP SEQUENCE ID_CURSO;
'DELETAR A SEQUENCE'

CREATE PUBLIC SYNONYM CURSOS_DBA FOR CURSOS;
'CRIAR SINONIMO(SYNONYM)'

SELECT * FROM CURSOS_DBA;
'MOSTRAR SINONIMO DA TABELA'

SELECT * FROM DBAACAD.CURSOS;

SELECT SYNONYM_NAME,TABLE_OWNER
FROM ALL_SYNONYMS
WHERE TABLE_NAME = 'CURSOS';
'CONFIRMAÇAO DA EXISTENCIA DE SINONIMO(SYNONYM)'

DROP PUBLIC SYNONYM CURSOS_DBA;
'DELETAR SINONIMO(SYNONYM)'

CREATE VIEW ARRECADADO_INST
AS
SELECT NOME_INSTRUTOR INSTRUTORES, SUM(PREÇO)
ARRECADADO
FROM INSTRUTORES I,  CURSOS C
WHERE I.COD_CURSO = C.COD_CURSO
GROUP BY NOME_INSTRUTOR
HAVING SUM(PREÇO) > 0;
'CRIA UMA VIEW QUE INFORME O QUANTO CADA INSTRUTOR ARRECADOU'

CREATE VIEW PAGOU
AS
SELECT NOME_ALUNO ALUNOS, NOME_CURSO CURSOS, SUM(PREÇO)
PAGO
FROM ALUNOS A,  CURSOS C
WHERE A.COD_CURSO = C.COD_CURSO
GROUP BY NOME_ALUNO, NOME_CURSO
HAVING SUM(PREÇO) > 0;
'CRIA UMA VIEW QUE MOSTRA ALUNOS,CURSOS E QUANTO CADA UM PAGOU'

CREATE VIEW MEDIAV
AS
SELECT NOME_CURSO CURSOS, AVG(MATRICULA)
MEDIA
FROM CURSOS C , ALUNOS A
WHERE C.COD_CURSO = A.COD_CURSO
GROUP BY NOME_CURSO
HAVING AVG(PREÇO) > 0;

SELECT * FROM MEDIAV ORDER BY MEDIA DESC;

DROP VIEW MEDIAV;

SELECT * FROM CURSOS;
SELECT * FROM ALUNOS;
SELECT * FROM TURMAS;


INSERT INTO ALUNOS
(MATRICULA,NOME_ALUNO,TEL_ALUNO,COD_CURSO)
VALUES
(4,'JOSE LUIZ',965656565,1);

ALTER TABLE INSTRUTORES
ADD(MATRICULA CONSTRAINT COD_CURSO_FK1 REFERENCES CURSOS(COD_CURSO));

SELECT * FROM INSTRUTORES;

UPDATE INSTRUTORES
SET COD_CURSO = 3
WHERE COD_INSTRUTOR = 3;

CREATE TABLE DEPONTA
(COD_DEPONTA NUMBER(03)
CONSTRAINT COD_DEPONTA_PK PRIMARY KEY);

CREATE SEQUENCE ID_PONTA
INCREMENT BY 1
START WITH 1
MAXVALUE 999
NOCYCLE;
'CRIA UM AUTO INCREMENTO'

INSERT INTO DEPONTA
(COD_DEPONTA)
VALUES(1);

SELECT * FROM DEPONTA;

DROP SEQUENCE ID_PONTA;

DELETE DEPONTA
WHERE COD_DEPONTA = 2;

INSERT INTO DEPONTA(COD_DEPONTA)
VALUES(ID_PONTA.NEXTVAL);

SELECT * FROM INSTRUTORES;

CREATE VIEW LISTADEPRESENÇA
AS
SELECT NOME_ALUNO, NOME_CURSO, CARGA_HORARIA, NOME_INSTRUTOR, SALA
FROM ALUNOS A,  CURSOS C, INSTRUTORES I, TURMAS T
WHERE A.MATRICULA = C.MATRICULA
AND  I.COD_INSTRUTOR = T.COD_INSTRUTOR
GROUP BY NOME_ALUNO, NOME_CURSO,CARGA_HORARIA, NOME_INSTRUTOR,SALA
ORDER BY 1;
'MOSTRA UMA LISTA DE PRESENÇA COM OS NOMES QUE ESTAO NO GROUP'

SELECT * FROM LISTADEPRESENÇA;

DROP VIEW LISTADEPRESENÇA

ALTER TABLE CURSOS
ADD(MATRICULA CONSTRAINT COD_ALUNO_FK REFERENCES ALUNOS(MATRICULA));

SELECT * FROM TURMAS;

UPDATE CURSOS
SET MATRICULA = 3
WHERE COD_CURSO = 3;

SELECT NOME_CURSO,PREÇO
FROM CURSOS
WHERE PREÇO = (SELECT MAX(PREÇO) FROM CURSOS);
'MOSTRA O NOME DO CURSO MAIS CARO'

UPDATE CURSOS
SET PREÇO = 1.1 * PREÇO
WHERE PREÇO = (SELECT MAX(PREÇO) FROM CURSOS);
'ATUALIZA OS CURSOS MAIS CAROS EM 10%'


CREATE TABLE MAIORES
AS
SELECT NOME_CURSO,PREÇO
FROM CURSOS
WHERE PREÇO > (SELECT AVG(PREÇO) FROM CURSOS);
'CRIA UMA TABELA QUE TENHAM OS CURSOS MAIS CAROS QUE A MEDIA DA TABELA CURSOS'

DELETE FROM MAIORES
WHERE PREÇO = (SELECT MIN(PREÇO) FROM MAIORES);
'ELIMINA O MAIS BARATO DOS MAIORES(TABELA)'

INSERT INTO MAIORES
(NOME_CURSO,PREÇO)
SELECT NOME_CURSO,PREÇO
FROM CURSOS
WHERE PREÇO < (SELECT AVG(PREÇO)FROM CURSOS);
'INSERE OS CURSOS CUJO O PREÇO SEJA MENOR QUE A MÉDIA DA TABELA CURSOS'


SELECT NOME_CURSO, CARGA_HORARIA
FROM CURSOS
WHERE CARGA_HORARIA IN (SELECT CARGA_HORARIA
FROM CURSOS
WHERE UPPER(NOME_CURSO)LIKE 'CURSO%')
AND UPPER(NOME_CURSO) NOT LIKE 'CURSO%';
'MOSTRA OS CURSOS QUE TENHAM A MESMA CARGA HORARIA DE QUALQUER UM QUE TENHA "CURSO" EM SEU NOME'

SELECT NOME_CURSO,CARGA_HORARIA
FROM CURSOS
WHERE CARGA_HORARIA NOT IN(SELECT CARGA_HORARIA
FROM CURSOS
WHERE UPPER(NOME_CURSO)LIKE 'CURSO%')
AND UPPER(NOME_CURSO) NOT LIKE 'CURSO%';
'MOSTRA OS CURSOS QUE NÃO TENHAM A MESMA CARGA HORARIA DE QUALQUER UM QUE TENHA "CURSO" EM SEU NOME'

UPDATE CURSOS
SET PREÇO = '160'
WHERE COD_CURSO = 5;

SELECT NOME_CURSO,PREÇO
FROM CURSOS
WHERE PREÇO < ANY
(SELECT PREÇO FROM CURSOS
WHERE UPPER(NOME_CURSO) LIKE 'DELPHI%')
AND UPPER(NOME_CURSO) NOT LIKE 'DELPHI%';
'MOSTRA OS CURSOS QUE NAO SEJAM DE DELPHI QUE TENHAM O PREÇO MENOR QUE O CURSO DE DELPHI'

SELECT * FROM CURSOS;

INSERT INTO CURSOS
(COD_CURSO,NOME_CURSO,CARGA_HORARIA,PREÇO,MATRICULA)
VALUES
(8,'LOGICA',10,150,8);

UPDATE CURSOS
SET NOME_CURSO = 'ADM', CARGA_HORARIA = 10
WHERE COD_CURSO = 3;

SELECT NOME_CURSO,PREÇO
FROM CURSOS
WHERE PREÇO > ALL
(SELECT PREÇO FROM CURSOS
WHERE UPPER(NOME_CURSO)LIKE 'DELPHI%')
AND UPPER(NOME_CURSO)NOT LIKE 'DELPHI%';
'MOSTRA TODOS OS CURSOS QUE NAO SEJAM DE DELPHI COM PREÇO MAIOR QUE O CURSO DE DELPHI'

UPDATE CURSOS
SET(CARGA_HORARIA,PREÇO) = 
(SELECT CARGA_HORARIA,PREÇO 
FROM CURSOS
WHERE COD_CURSO = 2)
WHERE COD_CURSO = 1;
'ATUALIZA O CURSO DO CODIGO 1 COM VALORES DO CURSO 2'

SELECT NOME_CURSO,CARGA_HORARIA,PREÇO,PRE_REQUISITO
FROM CURSOS
WHERE(CARGA_HORARIA,PREÇO) IN (SELECT CARGA_HORARIA,PREÇO
FROM CURSOS
WHERE PRE_REQUISITO IS NOT NULL);
'MOSTRA OS CURSOS, PREÇO E CARGA HORARIA QUE TENHAM O PRE REQUISITO'

CREATE VIEW V_SALAS
AS
SELECT SA.DESCRIÇAO SALA, T.DESCRIÇAO TIPO_SALA ,COUNT(MATRICULA)
ALUNOS
FROM TIPOS_SALAS T, SALAS SA, TURMAS TU, HISTORICO H
WHERE 
SA.COD_SALA = TU.SALA
AND TU.COD_TURMA = H.COD_TURMA
GROUP BY SA.DESCRIÇAO, T.DESCRIÇAO;
'MOSTRA AS MEDIA DOS ALUNOS POR TIPO SALA'

SELECT TIPO_SALA,AVG(ALUNOS) MEDIA
FROM V_SALAS
GROUP BY TIPO_SALA;
'MOSTRA A VIEW'

ALTER TABLE SALAS ADD(TIPO VARCHAR2(30));
'INCLUIR UMA COLUNA NUMA TABELA JÁ CRIADA'

UPDATE SALAS
SET TIPO = 
(SELECT DESCRIÇAO FROM TIPOS_SALAS
WHERE COD_TIPO_SALA = SALAS.TIPO);
'DESNORMALIZANDO A TABELA SALAS, ACRESCENTANDO UMA NOVA COLUNA'
"______________________________________________________________"
SELECT NOME_INSTRUTOR FROM INSTRUTORES I
WHERE COD_INSTRUTOR NOT IN
(SELECT COD_INSTRUTOR FROM TURMAS T
WHERE T.COD_INSTRUTOR  = I.COD_INSTRUTOR);

SELECT NOME_INSTRUTOR FROM INSTRUTORES I
WHERE NOT EXISTS
(SELECT COD_INSTRUTOR FROM TURMAS T
WHERE T.COD_INSTRUTOR = I.COD_INSTRUTOR);

SELECT NOME_INSTRUTOR FROM INSTRUTORES I
WHERE NOT EXISTS
(SELECT 1 FROM TURMAS T
WHERE T.COD_INSTRUTOR  = I.COD_INSTRUTOR);
'MOSTRA VALORES NULOS DE UMA TABELA'
"_____________________________________________________________"

SELECT * FROM HISTORICO;
SELECT * FROM CURSOS;
SELECT * FROM TURMAS;
SELECT * FROM ALUNOS;

UPDATE CURSOS
SET NOTA = 8
WHERE NOTA = (SELECT NOTA FROM CURSOS
WHERE UPPER(NOME_CURSO) LIKE 'DELPHI');

UPDATE HISTORICO H SET H.NOTA = 8 
WHERE H.COD_HIST IN (SELECT C.COD_CURSO FROM CURSOS C 
WHERE UPPER(C.NOME_CURSO) LIKE 'DELPHI' AND C.COD_CURSO = H.COD_HIST);

UPDATE HISTORICO
SET NOTA = 8.5
WHERE COD_HIST IN (SELECT COD_HIST FROM ALUNOS
WHERE UPPER(NOME_ALUNO) LIKE 'ZEBEDEU');
'ATUALIZA PARA NOTA 8.5 PARA O ALUNO ZEBEDEU'

UPDATE HISTORICO
SET NOTA = 7
WHERE COD_HIST IN (SELECT COD_HIST FROM ALUNOS
WHERE UPPER(NOME_ALUNO) LIKE 'YAMANDU'
OR(NOME_ALUNO)LIKE 'WELLINGTON'
OR(NOME_ALUNO)LIKE'TADEU');
'ATUALIZA PARA NOTA 7 PARA OS ALUNOS YAMANDU,WELLINGTON E TADEU'

UPDATE HISTORICO
SET NOTA = 8
WHERE COD_HIST IN (SELECT COD_HIST FROM CURSOS
WHERE UPPER(NOME_CURSO) LIKE 'DELPHI');
'ATUALIZA A NOTA PARA 8, PARA TODOS OS ALUNOS QUE CURSARAM DELPHI'

UPDATE CURSOS
SET PREÇO = 1.2 * PREÇO
WHERE COD_CURSO = (SELECT COUNT(COD_CURSO) FROM ALUNOS);

UPDATE CURSOS
SET PREÇO = 1.2 * PREÇO
WHERE MATRICULA IN (SELECT (5) FROM ALUNOS);

SELECT * FROM HISTORICO;
SELECT * FROM CURSOS;
SELECT * FROM TURMAS;
SELECT * FROM ALUNOS;
SELECT * FROM INSTRUTORES;

ALTER TABLE CURSOS ADD(ARRECADADO NUMBER (7,2));

INSERT INTO CURSOS
(ARRECADADO)
SELECT PREÇO
FROM CURSOS;
WHERE PREÇO IN (SELECT SUM(PREÇO)FROM CURSOS);

SELECT SUM(PREÇO)
ARRECADADO
FROM CURSOS;
'TOTAL ARRECADADO DOS CURSOS'          


SELECT NOME_CURSO, NOME_INSTRUTOR
MINISTRAM
FROM CURSOS C ,INSTRUTORES I
WHERE C.COD_INSTRUTOR = I.COD_INSTRUTOR
GROUP BY NOME_CURSO,NOME_INSTRUTOR
HAVING (NOME_CURSO) LIKE 'DELPHI';
'MOSTRAR INSTRUTORES QUE MINISTRAM O CURSO DELPHI'

CREATE OR REPLACE PROCEDURE ALIMENTAHISTORICO
(ULTIMA_TURMA IN NUMBER, 
ULTIMO_ALUNO IN NUMBER)IS
BEGIN
  DELETE HISTORICO;/*ELIMINA REGISTROS ATUAIS*/
  FOR I IN 1..ULTIMA_TURMA LOOP
    FOR J IN 1..ULTIMO_ALUNO LOOP
      INSERT INTO HISTORICO
      (COD_HIST,MATRICULA)
      VALUES
      (I,J);
      END LOOP;
      END LOOP;
      COMMIT;
      END;
       
        
SELECT OBJECT_NAME
FROM USER_OBJECTS
WHERE OBJECT_TYPE = 'PROCEDURE';
'VERIFICAR A EXISTENCIA DE UMA PROCEDURE'

CREATE OR REPLACE FUNCTION VALOREMDOLAR
(REAIS IN NUMBER,COTAÇAO IN NUMBER)
RETURN NUMBER IS
BEGIN
  RETURN REAIS/COTAÇAO;
END;
  
SELECT NOME_CURSO,
PREÇO "EM R$",
VALOREMDOLAR(PREÇO,1.87) "EM US$"
FROM CURSOS;
'EXECUÇÃO DA FUNCTION'

VARIABLE COTAÇAO NUMBER
EXEC: COTAÇAO:= 1.87
VARIABLE EM_DOLARES NUMBER
EXEC: EM_DOLARES := VALOREMDOLAR(1000,:COTAÇAO)
PRINT EM_DOLARES
SELECT VALOREMDOLAR(2000,1.92) FROM DUAL;

SELECT OBJECT_NAME
FROM USER_OBJECTS
WHERE OBJECT_TYPE = 'FUNCTION';
'VERIFICAR A EXISTENCIA DE UMA FUNCTION'

SELECT TEXT FROM USER_SOURCE WHERE NAME = 'VALOREMDOLAR';
"_______________________________________________________________"
CREATE OR REPLACE FUNCTION RECEBADOBRO (RETORNO IN NUMBER)
RETURN NUMBER IS RETORNONUMERO NUMBER;
BEGIN 
RETORNONUMERO := RETORNO+RETORNO;
  RETURN RETORNONUMERO;
  END;
  
  
  CREATE OR REPLACE FUNCTION dobraNumero(numero IN NUMBER) 
  RETURN NUMBER IS numeroretorno NUMBER;
  BEGIN numeroretorno := numero * numero ;
  return numeroretorno;
  end;
  'RECEBE UM VALOR E RETORNA O VALOR DOBRADO'
  
  SELECT NOME_CURSO,
PREÇO "EM R$",
RECEBADOBRO (PREÇO)"VALOR DOBRADO"
FROM CURSOS;
'MOSTRA O VALOR DOBRADO'

CREATE OR REPLACE PROCEDURE MOSTRADOBRO
(NUMERO IN OUT NUMBER )
IS
BEGIN
  NUMERO := NUMERO+NUMERO;
 END;
'PROCEDURE QUE RECEBE UM NUMERO E MOSTRA O VALOR DOBRADO'
 
 DECLARE
 NUMERO NUMBER:=10;
 BEGIN
  MOSTRADOBRO(NUMERO);
  DBMS_OUTPUT.PUT_LINE(NUMERO);
  END;
'MOSTRA O PROCEDURE QUE RECEBE UM NUMERO E MOSTRA O VALOR DOBRADO'
  
  CREATE OR REPLACE PROCEDURE MOSTRADOBRO
(NUMERO IN NUMBER DEFAULT 150)
IS
BEGIN
 DBMS_OUTPUT.PUT_LINE(NUMERO+NUMERO);
 END;
'PROCEDURE SEM ARGUMENTO'
  
 BEGIN
   MOSTRADOBRO;
  END;
'MOSTRA A PROCEDURE SEM ARGUMENTO COM O VALOR DOBRADO'

SELECT TEXT
FROM USER_SOURCE
WHERE NAME = 'MOSTRADOBRO';

SELECT OBJECT_NAME
FROM USER_OBJECTS
WHERE OBJECT_TYPE = 'PROCEDURE';

CREATE OR REPLACE FUNCTION CONTAMAIORESQUEMEDIA
RETURN NUMBER IS
TYPE TIPO_VETOR IS TABLE OF NUMBER(2) INDEX BY BINARY_INTEGER;
LISTA TIPO_VETOR;
I INTEGER;
SOMA INTEGER:=0;
QTOS NUMBER:=0;
MEDIA INTEGER;
BEGIN
LISTA(1):= 78;
LISTA(2):=60;
LISTA(3):=47;
LISTA(4):=50;
LISTA(5):=21;
FOR I IN 1..LISTA.COUNT LOOP
  SOMA:= SOMA + LISTA(I);
  END LOOP;
  MEDIA:= TRUNC(SOMA/LISTA.COUNT);
  FOR I IN 1..LISTA.COUNT LOOP
    IF LISTA(I)>MEDIA THEN
      QTOS:=QTOS+1;
      END IF;
      END LOOP;
       END;
       

CREATE OR REPLACE FUNCTION CONTAMAIORESQUEMEDIA
RETURN NUMBER IS

-- Para criar um vetor: TYPE nomeVetor IS VARRAY(n) OF x; n - tamanho do vetor. x - tipo do vetor.

TYPE TIPO_VETOR IS VARRAY(10) OF NUMBER;  

LISTA TIPO_VETOR; -- declarando uma espécie de  variável para o vetor
SOMA NUMBER:=0;
QTOS NUMBER:=0;
MEDIA NUMBER := 0;
tamanho NUMBER := 0; -- guardará o tamanho do vetor

BEGIN

LISTA:= TIPO_VETOR(10, 10, 10, 10, 10); -- atribuindo o valor 10 para 5 elementos do vetor.

tamanho := LISTA.count; -- atribundo o tamanho do vetor para a variável.

FOR x IN 1..tamanho LOOP -- percorrendo o vetor. Aqui é o mesmo que for(int x = 1; i <= 5; i++)
  SOMA:= SOMA + LISTA(x); 
  END LOOP;
  DBMS_OUTPUT.PUT_LINE('Valor da soma: '||SOMA); -- Printando a soma.
  MEDIA:= TRUNC(SOMA/LISTA.COUNT);
  DBMS_OUTPUT.PUT_LINE('Valor da média: '|| MEDIA); -- printando a média
  FOR x IN 1..tamanho LOOP 
    
    IF LISTA(x) > MEDIA THEN
      
      QTOS := QTOS + 1;
      
    END IF;
   
   END LOOP;  
   
   -- DBMS_OUTPUT.PUT_LINE(lista(2));
      
  RETURN QTOS; -- devolvendo a quantidade de elementos do vetor que são maiores que a média.
  
      
END;


DECLARE

x_num NUMBER;

BEGIN
  
 x_num :=  CONTAMAIORESQUEMEDIA;
 DBMS_OUTPUT.PUT_LINE(x_num || ' números são maiores que a média');

END; 

DECLARE
TYPE TIPO_REG_CURSO IS RECORD
(COD_CURSO NUMBER(3),
NOME_CURSO VARCHAR2(60),
CARGA_HORARIA NUMBER(3),
PREÇO NUMBER(7,3),
PRE_REQUISITO NUMBER(3));
REG_CURSO TIPO_REG_CURSO;
TYPE TIPO_TAB_CURSOS IS TABLE OF CURSOS % ROWTYPE
INDEX BY BINARY_INTEGER;
--TABELA EM MEMORIA--
REG_CURSO CURSOS%ROWTYPE;
-- CASO A VARIAVEL DE MEMORIA SEJA EXATAMENTE O REGISTRO DA TABELA--
BEGIN
REG_CURSO.CARGA_HORARIA:=20;
--ACESSO AS CAMPOS OU SEJA INCLUI VALORES--
END; 

CREATE OR REPLACE PROCEDURE ESCOPOCOMPLICADO IS
VALOR NUMBER(2):=30;
V2 NUMBER(3):=100;
BEGIN
  DECLARE/* AQUI COMEÇA O SEGUNDO BLOCO*/
  VALOR VARCHAR2(15):= 'AGORA É TEXTO';
  BEGIN
    DECLARE /*AQUI COMEÇA O TERCEIRO BLOCO*/
    VALOR DATE:=SYSDATE;
    BEGIN
      VALOR:= VALOR + 30;
      V2:= V2+1;
      END;
      VALOR:= 'OUTRO TEXTO';
      V2:= V2+1;
      END;
      VALOR:=VALOR+1;
      V2:=V2+1;
      DBMS_OUTPUT.PUT_LINE ('VALOR DE V2 É:  ' || V2 );
       DBMS_OUTPUT.PUT_LINE ('VALOR É:  ' || VALOR );
       --COLOCAR AQUI QUE APARECE NO COMAND WINDOW--
      END;
      
      
     
      
DECLARE

TAMANHO VARCHAR2(30):='JANEIRO';

BEGIN
  

 MESES;
 DBMS_OUTPUT.PUT_LINE(MESES);

END; 

     CREATE OR REPLACE PROCEDURE MESES1
  2   (TAMANHO IN NUMBER) IS
  3   BEGIN
  4     DBMS_OUTPUT.PUT_LINE(MESES(TAMANHO));
  5     END;


CREATE OR REPLACE FUNCTION CONTAMAIOR
RETURN NUMBER IS
TYPE TIPO_VETOR IS TABLE OF NUMBER(2) INDEX BY BINARY_INTEGER;
LISTA TIPO_VETOR;
I INTEGER;
SOMA INTEGER:=0;
QTOS NUMBER:=0;
MEDIA INTEGER;
BEGIN
LISTA(1):=78;
LISTA(2):=60;
LISTA(3):=47;
LISTA(4):=50;
LISTA(5):=21;
FOR I IN 1..LISTA.COUNT LOOP
  SOMA:=SOMA+LISTA(I);
  END LOOP;
  MEDIA:=TRUNC(SOMA/LISTA.COUNT);
  FOR I IN 1..LISTA.COUNT LOOP
    IF LISTA(I)> MEDIA THEN
      QTOS:=QTOS+1;
      DBMS_OUTPUT.put_line('VALOR DA SOMA: ' || SOMA);
      DBMS_OUTPUT.put_line('VALOR DA MEDIA: ' || MEDIA);
      RETURN QTOS;
      END IF;
      END LOOP;
      END;
"_________________________________________________________________"      
      CREATE OR REPLACE FUNCTION MESES
(TAMANHO IN NUMBER)
RETURN VARCHAR IS

TYPE TIPO_VETOR IS TABLE OF VARCHAR2(30) INDEX BY BINARY_INTEGER;
LISTA TIPO_VETOR;

BEGIN
LISTA(1):='JANEIRO';
LISTA(2):='FEVEREIRO';
LISTA(3):='MARÇO';
LISTA(4):='ABRIL';
LISTA(5):='MAIO';
LISTA(6):='JUNHO';
LISTA(7):='JULHO';
LISTA(8):='AGOSTO';
LISTA(9):='SETEMBRO';
LISTA(10):='OUTUBRO';
LISTA(11):='NOVEMBRO';
LISTA(12):='DEZEMBRO';

RETURN LISTA(TAMANHO);
END;

DECLARE 
   CALENDARIO NUMBER(03) := 1; 
BEGIN 
   CASE CALENDARIO 
      when '1' then dbms_output.put_line('JANEIRO'); 
      when '2' then dbms_output.put_line('FEVEREIRO'); 
      when '3' then dbms_output.put_line('MARÇO'); 
      when '4' then dbms_output.put_line('ABRIL'); 
      when '5' then dbms_output.put_line('MAIO');
      when '6' then dbms_output.put_line('JUNHO'); 
      when '7' then dbms_output.put_line('JULHO');
      when '8' then dbms_output.put_line('AGOSTO');
      when '9' then dbms_output.put_line('SETEMBRO');
      when '10' then dbms_output.put_line('OUTUBRO');
      when '11' then dbms_output.put_line('NOVEMBRO');
      when '12' then dbms_output.put_line('DEZEMBRO');
      else dbms_output.put_line('MES ERRADO'); 
   END CASE; 
END; 

CREATE OR REPLACE PROCEDURE CALENDARIO
(MES IN NUMBER) 
IS

BEGIN
   CASE MES 
      when '1' then dbms_output.put_line('JANEIRO'); 
      when '2' then dbms_output.put_line('FEVEREIRO'); 
      when '3' then dbms_output.put_line('MARÇO'); 
      when '4' then dbms_output.put_line('ABRIL'); 
      when '5' then dbms_output.put_line('MAIO');
      when '6' then dbms_output.put_line('JUNHO'); 
      when '7' then dbms_output.put_line('JULHO');
      when '8' then dbms_output.put_line('AGOSTO');
      when '9' then dbms_output.put_line('SETEMBRO');
      when '10' then dbms_output.put_line('OUTUBRO');
      when '11' then dbms_output.put_line('NOVEMBRO');
      when '12' then dbms_output.put_line('DEZEMBRO');
      else dbms_output.put_line('MES ERRADO'); 
   END CASE; 
END;
"_______________________________________________________________"

CREATE OR REPLACE PROCEDURE ARMAZENA
(N1 IN OUT NUMBER,
N2 IN OUT NUMBER)
IS
BEGIN
  N2:=N1;
  END;
  
  DECLARE
  N1 NUMBER:=100;
  N2 NUMBER :=1220;
  BEGIN
    ARMAZENA(N2,N1);
    DBMS_OUTPUT.PUT_LINE(N1);
    END;
'ARMAZENA DUAS VARIAVEIS E MOSTRA O CONTEUDO DIFERENTE DE UMA PARA OUTRA'

CREATE OR REPLACE PROCEDURE ACHEERRO IS
VALOR NUMBER(2):=30;
V2 NUMBER(2):=30;
BEGIN
  DECLARE /*AQUI COMEÇA O SEGUNDO BLOCO*/
  VALOR VARCHAR2(15):= 'AGORA É TEXTO';
  V3 NUMBER;
  BEGIN
    VALOR:='OUTRO TEXTO';
    V2:=V2+1;
    END;
    VALOR:=VALOR+1;
    V2:=V2+1;
    V3:=4;
    END;
    
    CREATE OR REPLACE FUNCTION MEDIA
    (VALOR IN NUMBER,VALOR2 IN NUMBER,VALOR3 IN NUMBER)
    RETURN NUMBER IS VMEDIA NUMBER;
    BEGIN
      VMEDIA := (VALOR+VALOR2+VALOR3);
      VMEDIA:= (VMEDIA/3);
      RETURN VMEDIA;
      END;
    
    CREATE OR REPLACE FUNCTION RECEBADOBRO (RETORNO IN NUMBER)
RETURN NUMBER IS RETORNONUMERO NUMBER;
BEGIN 
RETORNONUMERO := RETORNO+RETORNO;
  RETURN RETORNONUMERO;
  END;
  
CREATE OR REPLACE PROCEDURE RODARR
(VALOR IN NUMBER) IS
BEGIN
  DBMS_OUTPUT.PUT_LINE(MEDIA(VALOR));
  END;
    
  /*DECLARE 

  vmedia NUMBER;
  n1 NUMBER := 10;
  n2 NUMBER := 10;
  n3 NUMBER := 10;
  
BEGIN 
 
   SELECT AVG (n1+n2+n3)
   INTO  VMEDIA
   FROM dual;
   
   DBMS_OUTPUT.PUT_LINE(VMEDIA);


END;

   SELECT AVG (n1+n2+n3)
   INTO  VMEDIA
   FROM dual; -- Esse dual aqui é uma tabela da Oracle*/
   
   
   CREATE OR REPLACE PROCEDURE RETORNA_INFO_CURSO
   (V_CH IN CURSOS.CARGA_HORARIA % TYPE) IS
   V_NOME CURSOS.NOME_CURSO%TYPE;
   V_PREÇO CURSOS.PREÇO%TYPE;
   BEGIN
     SELECT NOME_CURSO,PREÇO
     INTO V_NOME,V_PREÇO
     FROM CURSOS
     WHERE CARGA_HORARIA = V_CH;
     DBMS_OUTPUT.PUT_LINE('CURSO: '||V_NOME);
     DBMS_OUTPUT.PUT_LINE('PREÇO: '||V_PREÇO);
     END;
     'VER NOME DO CURSO E PREÇO PELA CARGA HORARIA'
     
     
     CREATE OR REPLACE FUNCTION CALCULA_TOTAL_ARRECADADO
     RETURN NUMBER IS
     V_SOMA NUMBER;
     BEGIN
       SELECT SUM(PREÇO) INTO V_SOMA
       FROM CURSOS C, TURMAS T, HISTORICO H
       WHERE C.COD_CURSO = T.COD_CURSO
       AND T.COD_TURMA = H.COD_TURMA;
       RETURN V_SOMA;
       END;
       
       DECLARE
       NUMB NUMBER;
       BEGIN
         NUMB:=CALCULA_TOTAL_ARRECADADO ;
         DBMS_OUTPUT.PUT_LINE('TOTAL ARRECADADO: ' ||NUMB);
       END; 
       'MOSTRA O TOTAL ARRECADADO DE TODOS OS CURSOS'
       
       
       CREATE OR REPLACE PROCEDURE INSERE_INSTRUTOR
        (V_COD IN INSTRUTORES.COD_INSTRUTOR%TYPE,
        V_NOME IN INSTRUTORES.NOME_INSTRUTOR%TYPE,
        V_TEL IN INSTRUTORES.TEL_INSTRUTOR%TYPE,
        V_ADM IN INSTRUTORES.ADMISSAO%TYPE)IS
        BEGIN
          INSERT INTO INSTRUTORES
          (COD_INSTRUTOR,NOME_INSTRUTOR,TEL_INSTRUTOR,ADMISSAO)
          VALUES(GERA_V_COD.NEXTVAL, V_NOME,V_TEL,V_ADM);
          END;
          
EXECUTE INSERE_INSTRUTOR(45,'LUIS BRECUX',978787878,SYSDATE);
'INCLUI INFORMAÇOES PRA TABELA SEM PRECISAR FAZER UM INSERT'


CREATE OR REPLACE PROCEDURE ATUALIZA_TELEFONE_INSTRUTOR
(V_COD IN INSTRUTORES.COD_INSTRUTOR%TYPE,
V_NOVO_TEL IN INSTRUTORES.TEL_INSTRUTOR%TYPE)IS
BEGIN
  UPDATE INSTRUTORES
  SET TEL_INSTRUTOR = V_NOVO_TEL
  WHERE COD_INSTRUTOR = V_COD;
  COMMIT;
  END;
  
EXEC ATUALIZA_TELEFONE_INSTRUTOR(11,912121212);
SELECT * FROM INSTRUTORES WHERE COD_INSTRUTOR = 11;
'ATUALIZA DE UMA FORMA MAIS SIMPLES SEM PRECISAR DE UM INSERT'


CREATE OR REPLACE PROCEDURE ELIMINA_INSTRUTORES_SEM_TURMAS IS
BEGIN
  DELETE INSTRUTORES
  WHERE COD_INSTRUTOR NOT IN(SELECT DISTINCT COD_INSTRUTOR FROM TURMAS);
  END;
  
SELECT NOME_INSTRUTOR FROM INSTRUTORES
WHERE COD_INSTRUTOR NOT IN (SELECT DISTINCT COD_INSTRUTOR FROM TURMAS);
EXEC ELIMINA_INSTRUTORES_SEM TURMAS;
SELECT NOME_INSTRUTOR FROM INSTRUTORES
WHERE COD_INSTRUTOR NOT IN (SELECT DISTINCT COD_INSTRUTOR FROM TURMAS);
'ELIMINA INSTRUTORES SEM TURMAS'

CREATE OR REPLACE PROCEDURE CALCULA_ALUNOS
 (V_INST IN NUMBER) IS 
 BEGIN
   DBMS_OUTPUT.PUT_LINE(CALCULA_TOTAL_ALUNOS(V_INST));
   END;

CREATE OR REPLACE FUNCTION CALCULA_TOTAL_ALUNOS
(V_INST IN INSTRUTORES.COD_INSTRUTOR % TYPE)
     RETURN NUMBER IS
 V_ALUNOS ALUNOS.MATRICULA % TYPE;
     BEGIN
       SELECT SUM(MATRICULA) INTO V_ALUNOS
       FROM ALUNOS 
       WHERE COD_INSTRUTORES = V_INST;
       DBMS_OUTPUT.PUT_LINE('ARRECADADO: '||V_ALUNOS);
       RETURN V_INST;
       END;
       
       DECLARE
       NUMB NUMBER;
       BEGIN
         NUMB:=CALCULA_TOTAL_ALUNOS ;
         DBMS_OUTPUT.PUT_LINE('TOTAL ARRECADADO: ' ||NUMB);
       END; 
       
       SELECT * FROM ALUNOS;       
         
         SELECT (preco_curso * count(numero_alunos)) 
  into    valor_arrecadado
  
  
  CREATE OR REPLACE FUNCTION CALCULA_TOTAL_CODIGO
(V_COD IN CURSOS.COD_CURSO % TYPE)
     RETURN NUMBER IS
 V_PREÇO CURSOS.PREÇO % TYPE;
 V_TURMA TURMAS.COD_TURMA %TYPE;
     BEGIN
       SELECT SUM(PREÇO) INTO V_PREÇO
       FROM CURSOS C , TURMAS T  
       WHERE C.COD_CURSO = V_COD;
       DBMS_OUTPUT.PUT_LINE('ARRECADADO: '||V_PREÇO);
         DBMS_OUTPUT.PUT_LINE('COD_TURMA: '||V_TURMA);
       RETURN V_PREÇO;
       END;
       
       CREATE OR REPLACE FUNCTION CALCULA_TOTAL_CODIGO
(V_COD IN CURSOS.COD_CURSO % TYPE)
     RETURN NUMBER IS
 V_PREÇO CURSOS.PREÇO % TYPE;
 V_TURMA TURMAS.COD_TURMA %TYPE;
     BEGIN
       SELECT (PREÇO * COUNT(MATRICULA)) INTO V_PREÇO
       FROM CURSOS C , TURMAS T 
       WHERE C.COD_CURSO = T.COD_CURSO
       AND V_COD = C.COD_CURSO
       GROUP BY PREÇO;
       DBMS_OUTPUT.PUT_LINE('ARRECADADO: '||V_PREÇO);
         DBMS_OUTPUT.PUT_LINE('COD_TURMA: '||V_TURMA);
       RETURN V_TURMA;
       END;
       
       CREATE OR REPLACE FUNCTION CALCULA_TOTAL_ALUNOS
(V_INST IN INSTRUTORES.COD_INSTRUTOR % TYPE)
     RETURN NUMBER IS
 V_ALUNOS ALUNOS.MATRICULA % TYPE;
     BEGIN
       SELECT COUNT(MATRICULA) INTO V_ALUNOS
       FROM ALUNOS A, INSTRUTORES I
       WHERE A.COD_INSTRUTOR = I.COD_INSTRUTOR
       AND V_INST = I.COD_INSTRUTOR;
       DBMS_OUTPUT.PUT_LINE('ARRECADADO: '||V_ALUNOS);
       RETURN V_ALUNOS;
       END;
       
       CREATE SEQUENCE V_COD
INCREMENT BY 1
START WITH 1
MAXVALUE 999
NOCYCLE;

INSERT INTO CURSOS(COD_CURSO,NOME_CURSO)
VALUES(ID_CURSO.NEXTVAL,'ORACLE:ADMINISTRAÇAO');

SELECT * FROM ALUNOS;

EXECUTE INSERE_ALUNO('GILBERTO SILVA',932323232,'RJ');
'INCLUI INFORMAÇOES PRA TABELA SEM PRECISAR FAZER UM INSERT'

CREATE OR REPLACE PROCEDURE ATUALIZA_CIDADE_ALUNO
(V_COD IN ALUNOS.MATRICULA%TYPE,
V_NOVA_CID IN ALUNOS.CIDADE_ALUNO%TYPE)IS
BEGIN
  UPDATE ALUNOS
  SET CIDADE_ALUNO = V_NOVA_CID
  WHERE MATRICULA = V_COD;
  COMMIT;
  END;
  
CREATE OR REPLACE PROCEDURE AUMENTA_PREÇOS
(V_PREÇO IN CURSOS.PREÇO%TYPE,
V_NOME IN CURSOS.NOME_CURSO%TYPE)IS
BEGIN
  UPDATE CURSOS
  SET PREÇO = V_PREÇO * PREÇO
  WHERE NOME_CURSO = V_NOME;
  COMMIT;
  END;
  
EXECUTE AUMENTA_PREÇOS(20,'CURSO2LOGICA');
SELECT * FROM INSTRUTORES WHERE COD_INSTRUTOR = 11;
'ATUALIZA DE UMA FORMA MAIS SIMPLES SEM PRECISAR DE UM INSERT'

UPDATE CURSOS
SET PREÇO = 1.1 * PREÇO
WHERE PREÇO = (SELECT MAX(PREÇO) FROM CURSOS);
'ATUALIZA OS CURSOS MAIS CAROS EM 10%'

SELECT * FROM CURSOS;

CREATE OR REPLACE PROCEDURE ELIMINA_ALUNOS_SEM_CURSO IS
BEGIN
  DELETE ALUNOS
  WHERE COD_CURSO NOT IN(SELECT DISTINCT COD_CURSO FROM CURSOS);
  END;
  
SELECT NOME_ALUNO FROM ALUNOS
WHERE COD_CURSO NOT IN (SELECT DISTINCT COD_CURSO FROM CURSOS);
EXECUTE ELIMINA_ALUNOS_SEM_CURSO;
SELECT NOME_ALUNO FROM ALUNOS
WHERE COD_CURSO NOT IN (SELECT DISTINCT COD_CURSO FROM CURSOS);

SELECT * FROM ALUNOS;

CREATE OR REPLACE FUNCTION CLASSIFICA_ARRECADADO
RETURN VARCHAR2 IS
V_TOTAL NUMBER := 0;
BEGIN
  SELECT SUM(PREÇO) INTO V_TOTAL
  FROM CURSOS C, TURMAS T, HISTORICO H
  WHERE C.COD_CURSO = T.COD_CURSO
  AND T.COD_TURMA = H.COD_TURMA;
  
  IF V_TOTAL < 30000 THEN
    RETURN 'FRACO';
    ELSIF V_TOTAL < 50000 THEN
      RETURN 'MÉDIO';
      ELSE
        RETURN 'ALTO';
        END IF;
        END;
        
        
        BEGIN
          DBMS_OUTPUT.PUT_LINE(CLASSIFICA_ARRECADADO);
          END;
          
SELECT CLASSIFICA_ARRECADADO FROM DUAL;

CREATE OR REPLACE PROCEDURE ALIMENTA_HISTORICO_FOR
(ULTIMA_TURMA IN NUMBER,
ULTIMO_ALUNO IN NUMBER,
ULTIMO_HIST IN NUMBER) IS
BEGIN
  DELETE HISTORICO;
  FOR I IN 1..ULTIMA_TURMA LOOP
    FOR J IN 1..ULTIMO_ALUNO LOOP
      FOR X IN 1..ULTIMO_HIST LOOP
      INSERT INTO HISTORICO
      (COD_TURMA,MATRICULA,COD_HIST)
      VALUES
      (I,J,X);
      END LOOP;
      END LOOP;
      END LOOP;
      COMMIT;
      END;
      
      EXECUTE ALIMENTA_HISTORICO_FOR(1,1,1);
      SELECT COUNT(*) FROM HISTORICO;
'CRIA UM FOR PARA TABELA HISTORICO' 

CREATE OR REPLACE PROCEDURE ALIMENTA_HISTORICO_WHILE
(ULTIMA_TURMA IN NUMBER,
ULTIMO_ALUNO IN NUMBER,
ULTIMO_HIST IN NUMBER) IS
V_TURMA NUMBER(2) := 1;
V_ALUNO NUMBER(2) := 1;
V_HIST NUMBER(2) :=1;
BEGIN
  DELETE HISTORICO;
  WHILE V_TURMA <= ULTIMA_TURMA LOOP 'SE O VALOR DE V_TURMA FOR IGUAL A ULTIMA TURMA ELE PASSA E INSERE UM VALOR'
    WHILE V_ALUNO <= ULTIMO_ALUNO LOOP
      WHILE V_HIST <= ULTIMO_HIST LOOP
      INSERT INTO HISTORICO
      (COD_TURMA, MATRICULA,COD_HIST)
      VALUES (V_TURMA,V_ALUNO,V_HIST);
      V_ALUNO := V_ALUNO + 1;
      END LOOP;
      V_TURMA := V_TURMA + 1;
      END LOOP;
      V_HIST := V_HIST + 1;
      V_ALUNO := 1;
      END LOOP;
      COMMIT;
      END;
      
EXECUTE ALIMENTA_HISTORICO_WHILE(6,5)
SELECT COUNT(*) FROM HISTORICO;
'WHILE DA TABELA HISTORICO'

-- exibir numero de 1 até 10
DECLARE
  I NUMBER:=0;
BEGIN
    
  WHILE I<11
  LOOP
      DBMS_OUTPUT.PUT_LINE (I);
      I:=I+1;
  END LOOP;
END;

CREATE OR REPLACE PROCEDURE ALIMENTA_HISTORICO_NOTA_WHILE
(ULTIMA_NOTA IN NUMBER) IS
V_NOTA NUMBER(2) := 1;
BEGIN
  DELETE HISTORICO;
  WHILE V_NOTA <= ULTIMA_NOTA LOOP
      INSERT INTO HISTORICO
      (NOTA)
      VALUES (V_NOTA);
      V_NOTA := V_NOTA + 1;
      END LOOP
      COMMIT;
      END;
'SE O VALOR DE NOTA FOR 1 ELE PASSA E INSERE UM VALOR' 

CREATE OR REPLACE PROCEDURE ALIMENTA_HISTORICO_LOOP
(ULTIMA_TURMA IN NUMBER,
ULTIMO_ALUNO IN NUMBER,
ULTIMO_HIST IN NUMBER) IS
V_TURMA NUMBER(2) := 1;
V_ALUNO NUMBER(2) := 1;
V_HIST NUMBER(2) := 1;
BEGIN
  DELETE HISTORICO;
  LOOP
    LOOP
      LOOP
      INSERT INTO HISTORICO
      (COD_TURMA, MATRICULA, COD_HIST)
      VALUES
      (V_TURMA,V_ALUNO,V_HIST);
      V_ALUNO := V_ALUNO + 1;
      EXIT WHEN V_ALUNO > ULTIMO_ALUNO;
      END LOOP;
      V_TURMA := V_TURMA + 1;
      EXIT WHEN V_TURMA > ULTIMA_TURMA;
      END LOOP;
      V_HIST := V_HIST + 1;
      V_ALUNO := 1;
      EXIT WHEN V_HIST > ULTIMO_HIST;
      END LOOP;
      COMMIT;
      END;
'LOOP QUE INSERE UM VALOR NOS CAMPOS E INTERROMPE CASO O V_ALUNO FOR MAIOR QUE O ULTIMO_ALUNO'

CREATE OR REPLACE FUNCTION DEVOLVE_MAIOR
(N1 IN NUMBER, N2 IN NUMBER)
RETURN VARCHAR2 IS
MAIOR NUMBER;
BEGIN
  IF N1 > N2 THEN
    MAIOR := N1;
    RETURN 'MAIOR: ' ||MAIOR;
    ELSIF
      N1 < N2 THEN
      MAIOR := N2;
      RETURN 'MAIOR: ' ||MAIOR;
      ELSE
        RETURN 'SEM VALOR MAIOR';
      END IF;
      END;
      
CREATE OR REPLACE PROCEDURE DEVOLVE
(N1 IN NUMBER, N2 IN NUMBER)
IS 
BEGIN
  DBMS_OUTPUT.PUT_LINE(DEVOLVE_MAIOR(N1,N2));
  END;
        
DECLARE
N1 NUMBER:=0;
N2 NUMBER:=0;      
BEGIN
  DBMS_OUTPUT.PUT_LINE(DEVOLVE_MAIOR(N1,N2));
  END;
'DEVOLVE O NUMERO MAIOR, CASO NÃO HÁ VALOR MAIOR ELE RETORNA "SEM VALOR MAIOR"'


CREATE OR REPLACE FUNCTION CALENDARIO_IF
(MESES IN NUMBER)
RETURN VARCHAR2 IS
TYPE TIPO_VETOR IS TABLE OF VARCHAR2(30) INDEX BY BINARY_INTEGER;
MES TIPO_VETOR;
BEGIN
MES(1):='JANEIRO';
MES(2):='FEVEREIRO';
MES(3):='MARÇO';
MES(4):='ABRIL';
MES(5):='MAIO';
MES(6):='JUNHO';
MES(7):='JULHO';
MES(8):='AGOSTO';
MES(9):='SETEMBRO';
MES(10):='OUTUBRO';
MES(11):='NOVEMBRO';
MES(12):='DEZEMBRO';
  IF MESES =1  THEN
    RETURN MES(1);
    ELSIF MESES = 2 THEN
      RETURN MES(2);
      ELSIF MESES = 3 THEN
        RETURN MES(3);
        ELSIF MESES = 4 THEN
          RETURN MES(4);
          ELSIF MESES = 5 THEN
            RETURN MES(5);
            ELSIF MESES = 6 THEN
              RETURN MES(6);
              ELSIF MESES = 7 THEN
                RETURN MES(7);
                ELSIF MESES = 8 THEN
                  RETURN MES(8);
                  ELSIF MESES = 9 THEN
                    RETURN MES(9);
                    ELSIF MESES = 10 THEN
                      RETURN MES(10);
                      ELSIF MESES = 11 THEN
                        RETURN MES(11);
                        ELSIF MESES = 12 THEN
                          RETURN MES(12);
                          ELSE
                            RETURN 'MES INCORRETO';
        END IF;
        END;
        
CREATE OR REPLACE PROCEDURE RODA_CALENDARIO_IF 
(MESES IN NUMBER)
IS
BEGIN
DBMS_OUTPUT.PUT_LINE(CALENDARIO_IF(MESES));
END;
'RECEBE UM NUMERO ENTRE 1 E 12 E MOSTRA O NOME DO MES CORRESPONDENTE "COM IF"'

CREATE OR REPLACE PROCEDURE CLASSIFICA_CURSOS IS
  V_QTOS_CURSOS NUMBER (3) := 0;
  V_CURSO NUMBER(3):= 1;
  V_NOME_CURSO CURSOS.NOME_CURSO%TYPE;
  V_PREÇO CURSOS.PREÇO%TYPE;
  V_CLASSIFICA VARCHAR2(10);
  BEGIN
    SELECT COUNT (*)
    INTO V_QTOS_CURSOS
    FROM CURSOS;
    FOR I IN 1..V_QTOS_CURSOS LOOP
      SELECT NOME_CURSO, PREÇO
      INTO V_CURSO, V_PREÇO
      FROM CURSOS
      WHERE COD_CURSO = I;
      IF V_PREÇO < 300 THEN
        V_CLASSIFICA := 'BARATO';
        ELSIF V_PREÇO <600 THEN
          V_CLASSIFICA := 'MÉDIO';
          ELSE
            V_CLASSIFICA := 'CARO';
            END IF;
            DBMS_OUTPUT.PUT_LINE('CURSO: '|| V_NOME_CURSO || 'É '|| V_CLASSIFICA);
            END LOOP;
            END;
'MOSTRA OS CURSOS A PARTIR DO CODIGO "1", MOSTRA OS VALORES E DIZ SE É BARATO, MÉDIO OU CARO'

CREATE OR REPLACE FUNCTION EXCLUI_INSTRUTORES_CURSOR_IMP
RETURN VARCHAR2 IS
BEGIN
  DELETE INSTRUTORES
  WHERE COD_INSTRUTOR NOT IN(SELECT DISTINCT COD_INSTRUTOR FROM TURMAS);
  IF SQL%FOUND THEN
    RETURN('FORAM ELIMINADOS: '|| TO_CHAR(SQL%ROWCOUNT) || 'INSTRUTORES');
    ELSE
      RETURN('NENHUM INSTRUTOR ELIMINADO.');
      END IF;
      END;
      
CREATE OR REPLACE PROCEDURE RODAR_EXCLUI_INSTRUTORES
IS 
BEGIN
  DBMS_OUTPUT.PUT_LINE(EXCLUI_INSTRUTORES_CURSOR_IMP);
  END;
'EXCLUI INSTRUTORES SEM TURMAS, CURSOR IMPLICITO'

CREATE OR REPLACE PROCEDURE CLASSIFICA_CURSOS_CUR_EXP IS
CURSOR CCURSOS IS
SELECT NOME_CURSO, PREÇO FROM CURSOS;
V_NOME_CURSO CURSOS.NOME_CURSO%TYPE;
V_PREÇO CURSOS.PREÇO%TYPE;
V_CLASSIFICA VARCHAR2(10);
BEGIN
  OPEN CCURSOS;
  FETCH CCURSOS INTO V_NOME_CURSO, V_PREÇO;
  WHILE CCURSOS%FOUND LOOP
    IF V_PREÇO < 300 THEN
      V_CLASSIFICA := 'BARATO';
      ELSIF V_PREÇO < 600 THEN
        V_CLASSIFICA := 'MÉDIO';
        ELSE
          V_CLASSIFICA := 'CARO';
          END IF;
          DBMS_OUTPUT.PUT_LINE('CURSO: '|| V_NOME_CURSO || ' É ' || V_CLASSIFICA);
          FETCH CCURSOS INTO V_NOME_CURSO,V_PREÇO;
          END LOOP;
          CLOSE CCURSOS;
          END;
'MOSTRA OS CURSOS E DIZ SE É BARATO, MÉDIO OU CARO "CURSOR EXPLICITO"'

CREATE OR REPLACE PROCEDURE CLASS_CURSOS_EXP_PARAM
(V_VALOR_MINIMO NUMBER)IS
CURSOR CCURSOS(V_VALOR_MINIMO NUMBER)IS
SELECT NOME_CURSO,PREÇO FROM CURSOS
WHERE PREÇO > V_VALOR_MINIMO;
V_NOME_CURSO CURSOS.NOME_CURSO%TYPE;
V_PREÇO CURSOS.PREÇO%TYPE;

BEGIN
  OPEN CCURSOS(V_VALOR_MINIMO);
  FETCH CCURSOS INTO V_NOME_CURSO, V_PREÇO;
  WHILE CCURSOS%FOUND LOOP
  DBMS_OUTPUT.PUT_LINE(V_NOME_CURSO);
  DBMS_OUTPUT.PUT_LINE(V_PREÇO);
  FETCH CCURSOS INTO V_NOME_CURSO, V_PREÇO;
  END LOOP;
  CLOSE CCURSOS;
  END;
'MOSTRARA CURSOS COM O VALOR MAIOR QUE O COLOCADO'

CREATE OR REPLACE PROCEDURE CLASS_CURSOS_CUR_EXP_FOR IS
CURSOR CCURSOS IS
SELECT NOME_CURSO, PREÇO FROM CURSOS;
V_CLASSIFICA VARCHAR2(10);
BEGIN
  FOR REG_CURSO IN CCURSOS LOOP
    IF REG_CURSO.PREÇO < 300 THEN
      V_CLASSIFICA := 'BARATO';
      ELSIF REG_CURSO.PREÇO < 600 THEN
        V_CLASSIFICA := 'MÉDIO';
        ELSE
          V_CLASSIFICA := 'CARO';
          END IF;
          DBMS_OUTPUT.PUT_LINE('CURSO: '|| REG_CURSO.NOME_CURSO || ' É ' || V_CLASSIFICA);
          END LOOP;
          END; 
'MOSTRA OS CURSOS QUE ESTÃO NA FAIXA DE PREÇO ENTRE BARATO, MEDIO E CARO'

CREATE TABLE TURMAS_CURSOS AS
SELECT C.COD_CURSO COD_CURSO,PREÇO, COUNT(COD_TURMA) TURMAS
FROM CURSOS C, TURMAS T
WHERE C.COD_CURSO = T.COD_CURSO
GROUP BY C.COD_CURSO, PREÇO;

CREATE OR REPLACE PROCEDURE ATUALIZA_PREÇO_COM_CURSOR IS
CURSOR CCURSOS IS
SELECT COD_CURSO, PREÇO, TURMAS
FROM TURMAS_CURSOS
FOR UPDATE OF PREÇO NOWAIT;
BEGIN
  FOR LINHA_CORRENTE IN CCURSOS LOOP
    IF LINHA_CORRENTE.TURMAS > 2 THEN
      UPDATE TURMAS_CURSOS
      SET PREÇO = PREÇO * 1.1
      WHERE CURRENT OF CCURSOS;
      ELSE
        UPDATE TURMAS_CURSOS
        SET PREÇO = PREÇO * 0.9
        WHERE CURRENT OF CCURSOS;
        END IF;
        END LOOP;
        UPDATE CURSOS C
        SET PREÇO = (SELECT PREÇO FROM TURMAS_CURSOS
        WHERE COD_CURSO = C.COD_CURSO)
        WHERE COD_CURSO IN (SELECT COD_CURSO FROM TURMAS_CURSOS);
        END;
        COMMIT; 
'ATUALIZA PREÇOS DOS CURSOS QUE ESTÃO EM TURMAS'        
        
CREATE OR REPLACE PROCEDURE ATUALIZA_CURSO_DELPHI IS
CURSOR CCURSOS IS
SELECT C.COD_HIST, C.NOME_CURSO, H.NOTA
FROM CURSOS C, HISTORICO H;
BEGIN
  OPEN CCURSOS;
  UPDATE HISTORICO
SET NOTA = 8
WHERE COD_HIST IN (SELECT COD_HIST FROM CURSOS
WHERE UPPER(NOME_CURSO) LIKE 'DELPHI');
DBMS_OUTPUT.PUT_LINE('REGISTROS ALTERADOS: '|| SQL%ROWCOUNT);
CLOSE CCURSOS;
END;
'DA NOTA 8 PARA ALUNOS QUE CURSAM DELPHI E MOSTRA QUANTOS REGISTROS FORAM ALTERADOS'


CREATE OR REPLACE PROCEDURE TURMAS_INSTRUTORS IS
CURSOR CCURSOS IS
SELECT COD_INSTRUTOR , OBSOLESCENCIA
FROM INSTRUTORES;
CONTA_TURMA NUMBER;
STATUS  VARCHAR2(20);
BEGIN
  FOR x IN CCURSOS LOOP
    SELECT COUNT(T.COD_CURSO)
    INTO CONTA_TURMA
    FROM TURMAS T
    WHERE T.COD_INSTRUTOR = X.COD_INSTRUTOR;
    IF CONTA_TURMA = 0 THEN
      STATUS := 'ALTA';
    ELSIF CONTA_TURMA <= 2 THEN
        STATUS := 'MÉDIA';
    ELSE
        STATUS := 'BAIXA';
    END IF;
    UPDATE INSTRUTORES
    SET OBSOLESCENCIA = STATUS
    WHERE COD_INSTRUTOR = X.COD_INSTRUTOR;
    COMMIT;
  END LOOP;
END;


'LE A TABELA TURMAS, OLHA QUANTIDADE DE CURSOS E CADA INSTRUTOR QUE DA AULA, E APÓS ISSO, 
INSERE NA VARIAVEL OBSOLESCENCIA, 
SE O INSTRUTOR DE AULA PARA 0 TURMAS - ALTA, SE DER AULA PARA 1 OU DUAS - MÉDIA, DE 2 OU MAIS - BAIXA' 

CREATE OR REPLACE PROCEDURE TURMAS_INSTRUTOR IS
CURSOR CCURSOS IS
SELECT COD_INSTRUTOR, OBSOLESCENCIA
FROM INSTRUTORES I;
V_T NUMBER;
CRITERIO VARCHAR2(10);
BEGIN
  FOR X IN CCURSOS LOOP
  SELECT COUNT(T.COD_INSTRUTOR) INTO 
  V_T FROM TURMAS T 
  WHERE T.COD_INSTRUTOR = X.COD_INSTRUTOR;
  IF V_T = 0 THEN
   CRITERIO := 'ALTA';
   
    ELSIF V_T <= 2 THEN
      CRITERIO := 'MÉDIA';
    
        ELSE  
          CRITERIO := 'BAIXA';
          END IF;
          UPDATE INSTRUTORES
          SET OBSOLESCENCIA = CRITERIO
          WHERE COD_INSTRUTOR = X.COD_INSTRUTOR;
          COMMIT;
          END LOOP;
          END;
          
'LE A TABELA TURMAS, OLHA QUANTIDADE DE INSTRUTORES E CADA INSTRUTOR QUE DA AULA, E APÓS ISSO, 
INSERE NA VARIAVEL OBSOLESCENCIA, 
SE O INSTRUTOR DE AULA PARA 0 TURMAS - ALTA, SE DER AULA PARA 1 OU DUAS - MÉDIA, DE 2 OU MAIS - BAIXA'

CREATE OR REPLACE PROCEDURE ATUALIZA_CURSO IS

BEGIN
    UPDATE CURSOS 
    SET PREÇO = 1.2 * PREÇO
    WHERE PREÇO > (SELECT AVG(PREÇO) FROM CURSOS);
    UPDATE CURSOS
    SET PREÇO = 0.9 * PREÇO
    WHERE PREÇO < (SELECT AVG(PREÇO) FROM CURSOS);
    COMMIT;
    END;
'AUMENTA 20% O PREÇO DOS CURSOS MAIORES Q A MÉDIA E ABATE 10% OS CURSOS MENORES QUE A MÉDIA'

CREATE OR REPLACE FUNCTION RETORNA_INFO_CURSO_TRATADA
(V_CH IN CURSOS.CARGA_HORARIA%TYPE)
RETURN VARCHAR2 IS

V_NOME CURSOS.NOME_CURSO%TYPE;
V_PREÇO CURSOS.PREÇO%TYPE;
MSG VARCHAR2(60);
BEGIN
  SELECT NOME_CURSO,PREÇO
  INTO V_NOME, V_PREÇO
  FROM CURSOS
  WHERE CARGA_HORARIA = V_CH;
  RETURN ('CURSO: '|| V_NOME || CHR(10) || 'PREÇO: ' || TO_CHAR(V_PREÇO));

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN ('NENHUM CURSO POSSUI CARGA HORARIA ESPECIFICADA');
    WHEN TOO_MANY_ROWS THEN
      RETURN ('MUITOS CURSOS POSSUEM CARGA HORARIA ESPECIFICADA');
    WHEN OTHERS THEN
      MSG := 'ERRO DESCONHECIDO: '|| TO_CHAR(SQLCODE);
      RETURN(MSG);
      END;
      
      DECLARE
      V_CH NUMBER(02):= ;
      BEGIN
        DBMS_OUTPUT.PUT_LINE(RETORNA_INFO_CURSO_TRATADA(V_CH));
        END;  
        
        CREATE OR REPLACE PROCEDURE RODA_RETORNA_INFO_CURSO_TRAT
        (V_CH IN NUMBER)
        IS 
        BEGIN
          DBMS_OUTPUT.PUT_LINE(RETORNA_INFO_CURSO_TRATADA(V_CH));
          END;
'MOSTRA O VALOR DO CURSO ATRAVES DA CARGA HORARIA E COM EXCEPTION, OU SEJA ERROS COM INDENTIFICAÇÃO'

SELECT SUBSTR (TEXT,1,60) FROM ALL_SOURCE
WHERE NAME = 'STANDARD' AND TEXT LIKE '%EXCEPTION%';
'VER ERROS, COM EXCEPTION'

CREATE OR REPLACE FUNCTION INSERE_INSTRUTOR_TRATADA
(V_NOME IN INSTRUTORES.NOME_INSTRUTOR%TYPE,
V_TEL IN INSTRUTORES.TEL_INSTRUTOR%TYPE,
V_ADM IN INSTRUTORES.ADMISSAO%TYPE)
RETURN VARCHAR2 IS
NOME_NULO EXCEPTION;
PRAGMA EXCEPTION_INIT (NOME_NULO, -1400);
BEGIN
  INSERT INTO INSTRUTORES
  (COD_INSTRUTOR,NOME_INSTRUTOR, TEL_INSTRUTOR, ADMISSAO)
  VALUES (GERA_COD_INSTRUTOR.NEXTVAL, V_NOME, V_TEL, V_ADM);

  EXCEPTION
    WHEN NOME_NULO THEN
      RETURN('NAO FOI POSSIVEL INCLUIR: NOME NULO.');
      WHEN OTHERS THEN
        RETURN('ERRO DESCONHECIDO: '|| TO_CHAR(SQLCODE));
        END;
        
        DECLARE
         V_NOME CHAR(50);
        BEGIN
          V_NOME:= INSERE_INSTRUTOR_TRATADA(V_NOME => NULL,V_TEL => 950505050,V_ADM => SYSDATE);
          DBMS_OUTPUT.PUT_LINE(V_NOME);
          END;
'INSERE INFORMAÇÕES SEM PRECISAR DE EXECUTAR TODO O CODIGO E COM EXCEPTION'

CREATE OR REPLACE FUNCTION MATRICULA_ALUNO_COM_RAISE
(V_TURMA IN HISTORICO.COD_TURMA%TYPE,
V_MATRICULA IN HISTORICO.MATRICULA%TYPE)
RETURN VARCHAR2 IS
MAX_ALUNOS CONSTANT INTEGER := 10;
V_ALUNOS_NA_TURMA INTEGER;
TURMA_CHEIA EXCEPTION;
BEGIN
  SELECT COUNT(MATRICULA)
  INTO V_ALUNOS_NA_TURMA
  FROM HISTORICO
  WHERE COD_TURMA = V_TURMA;
  IF V_ALUNOS_NA_TURMA = MAX_ALUNOS THEN
    RAISE TURMA_CHEIA;
    ELSE
      INSERT INTO HISTORICO(COD_TURMA,MATRICULA,COD_HIST) VALUES(V_TURMA,V_MATRICULA,NULL);
      COMMIT;
      RETURN('INCLUSAO OK!');
      END IF;
      EXCEPTION
        WHEN TURMA_CHEIA THEN
          RETURN('NAO FOI POSSIVEL INCLUIR: TURMA_CHEIA');
          WHEN OTHERS THEN
            RETURN('ERRO DESCONHECIDO: '|| TO_CHAR(SQLCODE));
            END;
            
DECLARE
TEXTO VARCHAR(80);
BEGIN
  TEXTO:=MATRICULA_ALUNO_COM_RAISE(1,60);
  DBMS_OUTPUT.PUT_LINE(TEXTO);
  END;
'INSERE NA TABELA HISTORICO E SE TIVER O MAXIMO DE 10 ALUNOS APRESENTA 'TURMA CHEIA' COM EXCEPTION'

CREATE OR REPLACE FUNCTION MATRICULA_COM_RAISE_APP_ERROR
(V_TURMA IN HISTORICO.COD_TURMA%TYPE,
V_MATRICULA IN HISTORICO.MATRICULA%TYPE)
RETURN VARCHAR2 IS
MAX_ALUNOS CONSTANT INTEGER:=10;
V_ALUNOS_NA_TURMA INTEGER;
BEGIN
  SELECT COUNT(MATRICULA)
  INTO V_ALUNOS_NA_TURMA
  FROM HISTORICO
  WHERE COD_TURMA = V_TURMA;
  IF V_ALUNOS_NA_TURMA >= MAX_ALUNOS THEN
    RAISE_APPLICATION_ERROR (-20500, 'TURMA_CHEIA');
    ELSE
      INSERT INTO HISTORICO (COD_TURMA, MATRICULA,COD_HIST)VALUES(V_TURMA,V_MATRICULA,NULL);
      COMMIT;
      RETURN('INCLUSAO OK!');
      END IF;
      END;
    
DECLARE    
TEXTO VARCHAR(50);
BEGIN
  TEXTO := MATRICULA_COM_RAISE_APP_ERROR(10,21);
END;
'INSERE NA TABELA HISTORICO E SE TIVER O MAXIMO DE 10 ALUNOS APRESENTA 'TURMA CHEIA' COM EXCEPTION'

CREATE OR REPLACE PROCEDURE EXCLUIR_ALUNO IS
CURSOR CCURSOS IS
SELECT MATRICULA
FROM ALUNOS;
V_T NUMBER;
MAT EXCEPTION;
BEGIN
  FOR X IN CCURSOS LOOP
    SELECT COUNT(MATRICULA)
    INTO V_T FROM TURMAS 
    WHERE MATRICULA = X.MATRICULA;
    IF V_T > 0 THEN
      RAISE MAT;
      ELSE
        DELETE ALUNOS
        WHERE MATRICULA IN(SELECT MATRICULA FROM TURMAS);
        DBMS_OUTPUT.PUT_LINE('ALUNO EXCLUIDO');
        COMMIT;
        END IF;
        END LOOP;
        EXCEPTION
          WHEN MAT THEN
            DBMS_OUTPUT.PUT_LINE('ALUNO MATRICULADO');
        END; 
'IMPEDE DE EXCLUIR UM ALUNO CASO ELE ESTEJA MATRICULADO EM ALGUMA TURMA E MOSTRA O EXCEPTION'

CREATE OR REPLACE PROCEDURE CANCELA_ALUNO IS
CURSOR CCURSOS IS
SELECT MATRICULA
FROM ALUNOS;
V_T NUMBER;
MSG EXCEPTION;
BEGIN
  FOR X IN CCURSOS LOOP
    SELECT (MATRICULA)
    INTO V_T FROM TURMAS 
    WHERE MATRICULA = X.MATRICULA;
    IF V_T = 5 THEN
      UPDATE ALUNOS
      SET NOME_ALUNO = 'JOSE ELIAS'
      WHERE MATRICULA IN(SELECT MATRICULA FROM TURMAS);
      DBMS_OUTPUT.PUT_LINE('ALUNO CANCELADO');
      ELSE
        RAISE MSG;
        END IF;
        END LOOP;
        EXCEPTION
          WHEN MSG THEN
            DBMS_OUTPUT.PUT_LINE('ALUNO SEM TURMA');
            END;
        
UPDATE TURMAS
SET MATRICULA = 5
WHERE COD_TURMA = 5;

SELECT * FROM HISTORICO;
UPDATE TURMAS
SET MATRICULA = ''
WHERE COD_TURMA = 5;

SELECT * FROM HISTORICO;
DELETE HISTORICO
WHERE COD_TURMA = 3;

INSERT INTO ALUNOS
(MATRICULA)
VALUES
(6,'');

ALTER TABLE CURSOS READ ONLY;

CREATE OR REPLACE PROCEDURE RODA_MATRICULA_RAISE
(V_MATRICULA IN NUMBER,V_TURMA IN NUMBER,V_HIST IN NUMBER)
IS 
BEGIN
  DBMS_OUTPUT.PUT_LINE(matricula_aluno_com_raise(V_MATRICULA,V_TURMA,V_HIST));
  END; 
'ADICIONA MAIS UM CODIGO PARA TABELA HISTORICO, CASO JÁ EXISTA NÃO ACEITA OU SEJA MAIOR QUE O PERMITIDO'
  
CREATE OR REPLACE PACKAGE PACK_INTRUTORES IS 
PROCEDURE ELIMINA_INSTRUTORES_SEM_TURMAS;
FUNCTION INSERE_INSTRUTOR_TRATADA
  (V_NOME IN INSTRUTORES.NOME_INSTRUTOR%TYPE,
  V_TEL IN INSTRUTORES.TEL_INSTRUTOR%TYPE,
  V_ADM IN INSTRUTORES.ADMISSAO%TYPE)
  RETURN VARCHAR2;
  END PACK_INSTRUTORES;    
  
CREATE OR REPLACE PACKAGE BODY PACK_INSTRUTORES IS
PROCEDURE ELIMINA_INSTRUTORES_SEM_TURMAS IS
  BEGIN
    DELETE INSTRUTORES
    WHERE COD_INSTRUTOR NOT IN (SELECT DISTINCT COD_INSTRUTOR FROM TURMAS);
    END;

FUNCTION INSERE_INSTRUTOR_TRATADA
    (V_NOME IN INSTRUTORES.NOME_INSTRUTOR%TYPE,
    V_TEL IN INSTRUTORES.TEL_INSTRUTOR%TYPE,
    V_ADM IN INSTRUTORES.ADMISSAO%TYPE)
    RETURN VARCHAR2 IS
    NOME_NULO EXCEPTION;
    PRAGMA EXCEPTION_INIT (NOME_NULO, -1400);

    BEGIN
    INSERT INTO INSTRUTORES
    (COD_INSTRUTOR, NOME_INSTRUTOR, TEL_INSTRUTOR, ADMISSAO)
    VALUES (GERA_COD_INSTRUTOR.NEXTVAL, V_NOME, V_TEL, V_ADM);
    EXCEPTION
      WHEN NOME_NULO THEN
        RETURN ('NÃO FOI POSSIVEL INCLUIR: NOME NULO.');
        WHEN OTHERS THEN
          RETURN ('ERRO DESCONHECIDO: ' || TO_CHAR (SQLCODE));
            END;
            END;
            
SELECT OBJECT_NAME FROM USER_OBJECTS WHERE OBJECT_TYPE = 'PACKAGE'; 
'PROCURAR PACKAGE'

DECLARE
V_NOME VARCHAR2(80);
BEGIN
  V_NOME:=PACK_INSTRUTORES.INSERE_INSTRUTOR_TRATADA
  (V_NOME => 'JOSIAS', V_TEL => 950505050, V_ADM => SYSDATE);
  DBMS_OUTPUT.PUT_LINE(V_NOME);
  END;
'RODAR UM PACKAGE COM FUNCTION'  

SELECT *
FROM USER_SOURCE A
WHERE UPPER(A.TEXT) LIKE '%FUNCTION%'; 

BEGIN
  PACK_INSTRUTORES.ELIMINA_INSTRUTORES_SEM_TURMAS;
  END; 
'RODAR UM PACKAGE COM PROCEDURE'  
  
SELECT * FROM INSTRUTORES; 


SELECT PROCEDURE_NAME
FROM ALUNOS 
WHERE UPPER 
ORDER BY 3,2,1;
'MOSTRA PROCEDURES E FUNCTION E PACKAGE E BODY E DIZ SE É INVALIDO OU VALIDO'

SELECT OBJECT_NAME, OBJECT_TYPE TIPO,STATUS
FROM USER_OBJECTS 
WHERE OBJECT_TYPE IN ('PROCEDURE','FUNCTION','PACKAGE','PACKAGE BODY')
ORDER BY 3,2,1;

SELECT OBJECT_NAME ALUNO, OBJECT_TYPE TIPO
FROM ALUNOS;
WHERE OBJECT_TYPE IN ('PROCEDURE', 'FUNCTION') ; 

SELECT TEXT
FROM ALUNOS
WHERE TYPE IN ('FUNCTION'); 

SELECT TABLE_NAME
FROM 
WHERE TABLE_NAME LIKE '%TABLE%';

SELECT *
FROM DBA_DEPENDENCIES
WHERE referenced_name = 'ALUNOS' --nome da tabela
AND TYPE IN ('PROCEDURE', 'FUNCTION'); --tipo da referencia

SELECT OBJECT_NAME, OBJECT_TYPE, REFERENCED_NAME
FROM USER_OBJECTS, DBA_DEPENDENCIES
WHERE OBJECT_TYPE IN ('PROCEDURE','FUNCTION')
AND OBJECT_NAME LIKE '%ALUNO%'
AND REFERENCED_NAME = 'ALUNOS';
'PROCEDURES E FUNCTION DA TABELA ALUNOS COM O NOME ALUNO'

SELECT * FROM DEPTREE;

SELECT OBJECT_NAME, OBJECT_TYPE
FROM USER_OBJECTS, DEPTREE
WHERE OBJECT_TYPE IN('PROCEDURE','FUNCTION')
AND OBJECT_NAME LIKE '%ALUNO%';
'PROCEDURES E FUNCTIONS QUE TENHAM O NOME ALUNO, EM UMA VIEW'

CREATE OR REPLACE PACKAGE PACK_ALUNOS IS
PROCEDURE ATUALIZA_CIDADE_ALUNO(V_COD IN NOVAALUNOS.MATRICULA%TYPE, 
V_NOVA_CID IN ALUNOS.CIDADE_ALUNO%TYPE);
PROCEDURE CALCULA_ALUNOS(V_INST IN NUMBER);
PROCEDURE CANCELA_ALUNO(MAT NOVAALUNOS.MATRICULA%TYPE);
PROCEDURE ELIMINA_ALUNOS_SEM_CURSO;
PROCEDURE EXCLUIR_ALUNO;
PROCEDURE INSERE_ALUNO(V_NOME IN ALUNOS.NOME_ALUNO%TYPE,
        V_TEL IN NOVAALUNOS.TEL_ALUNO%TYPE,
        V_CID IN NOVAALUNOS.CIDADE_ALUNO%TYPE DEFAULT 'RIO DE JANEIRO');
FUNCTION MATRICULA_ALUNO_COM_RAISE(V_MATRICULA IN HISTORICO.MATRICULA%TYPE,
V_TURMA IN HISTORICO.COD_TURMA%TYPE,
V_HIST IN HISTORICO.COD_HIST%TYPE)
RETURN VARCHAR2;
FUNCTION CALCULA_TOTAL_ALUNOS(V_INST IN INSTRUTORES.COD_INSTRUTOR % TYPE)
     RETURN NUMBER;
END;
'PACKAGE SPEC ALUNOS COM PROCEDURES E FUNCTION QUE CONTENHAM O NOME ALUNO' 

CREATE OR REPLACE PACKAGE BODY PACK_ALUNOS IS
PROCEDURE ATUALIZA_CIDADE_ALUNO  (V_COD IN ALUNOS.MATRICULA%TYPE,
V_NOVA_CID IN ALUNOS.CIDADE_ALUNO%TYPE)IS
BEGIN
  UPDATE NOVAALUNOS
  SET CIDADE_ALUNO = V_NOVA_CID
  WHERE MATRICULA = V_COD;
  COMMIT;
  END;

PROCEDURE CALCULA_ALUNOS  (V_INST IN NUMBER)IS
   BEGIN
   DBMS_OUTPUT.PUT_LINE(CALCULA_TOTAL_ALUNOS(V_INST));
   END;

PROCEDURE CANCELA_ALUNO(MAT ALUNOS.MATRICULA%TYPE) IS

V_T NUMBER;
MSG EXCEPTION;
BEGIN
    SELECT MATRICULA
    INTO V_T FROM TURMAS T
    WHERE MATRICULA = MAT;
    IF V_T = MAT THEN
      DELETE FROM NOVAALUNOS
      WHERE MATRICULA = MAT;
      DBMS_OUTPUT.PUT_LINE('ALUNO CANCELADO');
      ELSE
        RAISE MSG;
        END IF;
        EXCEPTION
          WHEN MSG THEN
            DBMS_OUTPUT.PUT_LINE('ALUNO SEM TURMA');
            WHEN NO_DATA_FOUND THEN
              DBMS_OUTPUT.PUT_LINE('NAO POSSUI TURMA');
            END;

PROCEDURE ELIMINA_ALUNOS_SEM_CURSO IS
BEGIN
  DELETE NOVAALUNOS
  WHERE COD_CURSO IS NULL;
  COMMIT;
  END;

PROCEDURE EXCLUIR_ALUNO IS
CURSOR CCURSOS IS
SELECT MATRICULA
FROM NOVAALUNOS;
V_T NUMBER;
MAT EXCEPTION;
BEGIN
  FOR X IN CCURSOS LOOP
    SELECT COUNT(MATRICULA)
    INTO V_T FROM TURMAS
    WHERE MATRICULA = X.MATRICULA;
    IF V_T > 0 THEN
      RAISE MAT;
      ELSE
        DELETE ALUNOS
        WHERE MATRICULA IN(SELECT MATRICULA FROM TURMAS);
        DBMS_OUTPUT.PUT_LINE('ALUNO EXCLUIDO');
        COMMIT;
        END IF;
        END LOOP;
        EXCEPTION
          WHEN MAT THEN
            DBMS_OUTPUT.PUT_LINE('ALUNO MATRICULADO');
        END;

PROCEDURE INSERE_ALUNO
  (V_NOME IN NOVAALUNOS.NOME_ALUNO%TYPE,
        V_TEL IN NOVAALUNOS.TEL_ALUNO%TYPE,
        V_CID IN NOVAALUNOS.CIDADE_ALUNO%TYPE DEFAULT 'RIO DE JANEIRO')
        IS
        BEGIN
          INSERT INTO NOVAALUNOS
          (MATRICULA,NOME_ALUNO,TEL_ALUNO,CIDADE_ALUNO)
          VALUES( V_COD.NEXTVAL, V_NOME,V_TEL,V_CID);
          END;

FUNCTION MATRICULA_ALUNO_COM_RAISE
  (V_MATRICULA IN HISTORICO.MATRICULA%TYPE,
V_TURMA IN HISTORICO.COD_TURMA%TYPE,
V_HIST IN HISTORICO.COD_HIST%TYPE)
RETURN VARCHAR2 IS
MAX_ALUNOS NUMBER := 10;
V_ALUNOS_NA_TURMA NUMBER;
TURMA_CHEIA EXCEPTION;
CONS EXCEPTION;

BEGIN
  SELECT COUNT(MATRICULA)
  INTO V_ALUNOS_NA_TURMA
  FROM HISTORICO
  WHERE COD_TURMA = V_TURMA;
  IF V_ALUNOS_NA_TURMA >= MAX_ALUNOS THEN
    RAISE TURMA_CHEIA;
    ELSIF V_ALUNOS_NA_TURMA > 0 THEN
      RETURN('IMPOSSIVEL ADICIONAR');
    ELSE
      INSERT INTO HISTORICO(COD_TURMA,MATRICULA,COD_HIST) VALUES(V_TURMA,V_MATRICULA,V_HIST);
      COMMIT;
      RETURN('INCLUSAO OK!');
      END IF;
      EXCEPTION
        WHEN TURMA_CHEIA THEN
          RETURN('NAO FOI POSSIVEL INCLUIR: || TURMA_CHEIA');
          WHEN OTHERS THEN
            RETURN('ERRO DESCONHECIDO: '|| TO_CHAR(SQLCODE));
            END;
            
            FUNCTION CALCULA_TOTAL_ALUNOS(V_INST IN INSTRUTORES.COD_INSTRUTOR % TYPE)
     RETURN NUMBER IS
 V_ALUNOS NOVAALUNOS.MATRICULA % TYPE;
     BEGIN
       SELECT COUNT(MATRICULA) INTO V_ALUNOS
       FROM NOVAALUNOS A, INSTRUTORES I
       WHERE A.COD_INSTRUTOR = I.COD_INSTRUTOR
       AND V_INST = I.COD_INSTRUTOR;
       DBMS_OUTPUT.PUT_LINE('ARRECADADO: '||V_ALUNOS);
       RETURN V_ALUNOS;
       END;
       END;
'PACKAGE BODY COM PROCEDURES E FUNCTIONS CONTENHAM O NOME ALUNO'                   
            
DROP PROCEDURE 
'APAGAR PROCEDURE'

RENAME ALUNOS TO NOVAALUNOS;
'RENOMEAR UMA TABELA'

CREATE OR REPLACE TRIGGER T_AFT_UPD_RPW_AUMENTAPREÇOS
AFTER UPDATE
ON CURSOS
FOR EACH ROW
  BEGIN
    IF :NEW.PREÇO > 1200 THEN
      RAISE_APPLICATION_ERROR(-20500, 'TENTATIVA EXAGERADA DE AUMENTO!');
      END IF;
      END;
'TRIGGER QUE CRIA UM EXCEPTION E NÃO DEIXA CADASTRAR, CASO TENTE PASSAR DE 1200 NO PREÇO DO CURSO'      

SELECT TRIGGER_NAME FROM USER_TRIGGERS;
'PROCURAR TRIGGERS'

ALTER TRIGGER T_AFT_UPD_RPW_AUMENTAPREÇOS ENABLE;
'HABILITAR TRIGGER'

ALTER TRIGGER T_AFT_UPD_RPW_AUMENTAPREÇOS DISABLE;
'DESABILITAR TRIGGER'

DROP TRIGGER  T_AFT_UPD_RPW_AUMENTAPREÇOS;
'APAGAR TRIGGER'

CREATE OR REPLACE TRIGGER T_BEF_INS_ROW_INSERE_ALUNO
BEFORE INSERT
ON NOVAALUNOS
FOR EACH ROW
  DECLARE
  NOVA_MATRICULA NUMBER;
  BEGIN
    SELECT GERA_MATR_ALUNO.NEXTVAL
    INTO NOVA_MATRICULA FROM DUAL;
    :NEW.MATRICULA := NOVA_MATRICULA;
    END;
'INSERINDO UMA NOVA MATRICULA COM AUTO INCREMENTO'    

INSERT INTO NOVAALUNOS(NOME_ALUNO)
VALUES ('FRANCISCO MUSCA');
'INCLUINDO UM ALUNO COM O AUTO INCREMENTO'
    
    CREATE SEQUENCE GERA_MATR_ALUNO
INCREMENT BY 1 - QUANTAS QUE VAI
START WITH 6 - ONDE INICIA
MAXVALUE 999 - MAXIMO
NOCYCLE;
'CRIAR SEQUENCE'

CREATE OR REPLACE TRIGGER T_BEF_UPD_STM_REGISTRO
BEFORE UPDATE
ON CURSOS
BEGIN
  UPDATE TAB_AUDITORIA
  SET ATUALIZAÇOES = ATUALIZAÇOES + 1;
  END;
'A CADA UPDATE NA TABELA CURSOS, AUMENTA UMA ATUALIZAÇÃO NA TABELA TAB_AUDITORIA'  
  
CREATE TABLE TAB_AUDITORIA (ATUALIZAÇOES NUMBER);

INSERT INTO TAB_AUDITORIA VALUES(0);

UPDATE CURSOS SET PREÇO = 100
WHERE COD_CURSO = 1;

SELECT * FROM TAB_AUDITORIA;

CREATE OR REPLACE TRIGGER T_BEF_ROW_LIMPAHIST
BEFORE DELETE
ON TURMAS
FOR EACH ROW
  BEGIN
    DELETE HISTORICO
    WHERE COD_TURMA = OLD.COD_TURMA;
    END;
'APAGA TABELA TURMAS E TIRA AS INFORMAÇOES DA TABELA HISTORICO'    
    
ALTER TABLE HISTORICO
DISABLE CONSTRAINT HISTORICO_TURMA_FK;

SELECT COUNT(*) FROM HISTORICO;

SELECT COUNT(*) FROM TURMAS;

DELETE TURMAS;

SELECT COUNT (*) FROM HISTORICO;

ROLLBACK;

CREATE OR REPLACE TRIGGER T_BEF_UPDINS_STM_MULTHIST
BEFORE INSERT OR UPDATE
ON HISTORICO
DECLARE
V_HOJE NUMBER;
V_AGORA NUMBER;
BEGIN
  V_HOJE := TO_NUMBER(TO_CHAR(SYSDATE,'D'));
  V_AGORA := TO_NUMBER(TO_CHAR(SYSDATE,'HH24MI'));
  IF INSERTING THEN
    IF V_AGORA > 1830 THEN
      RAISE_APPLICATION_ERROR(-20600,'HORA PROIBIDA PARA INSERÇOES');
      END IF;
      ELSE
        IF V_HOJE = 1 THEN
          RAISE_APPLICATION_ERROR (-20700,'DIA PROIBIDO PARA ATUALIZAÇOES');
          END IF;
          END IF;
          END;
'NÃO DEIXA ATUALIZAR APOS AS 18:30 OU DIA DE DOMINGO'     

INSERT INTO HISTORICO VALUES (3,3,10,3);
    
SELECT * FROM HISTORICO;

DELETE HISTORICO
WHERE COD_TURMA = 3;

CREATE OR REPLACE TRIGGER INS_HIS_NOVAALUNO
BEFORE INSERT OR UPDATE
ON HISTORICO
FOR EACH ROW
DECLARE
NOVA_TURMA NUMBER;
NOVA_ALUNO NUMBER;
ERRO EXCEPTION;
BEGIN
   SELECT COUNT (COD_TURMA) 
   INTO NOVA_TURMA FROM TURMAS 
   WHERE COD_TURMA = :NEW.COD_TURMA;
   SELECT COUNT (MATRICULA)
   INTO NOVA_ALUNO FROM NOVAALUNOS
   WHERE MATRICULA = :NEW.MATRICULA;
   IF NOVA_TURMA = 0 THEN
     RAISE ERRO;
     ELSIF NOVA_ALUNO = 0 THEN 
       RAISE ERRO;
       ELSE
         DBMS_OUTPUT.PUT_LINE('ADICIONADO');
         END IF;
         EXCEPTION
           WHEN ERRO THEN
             RAISE_APPLICATION_ERROR(-20001, 'NÃO HÁ REGISTRO NA TABELA');
   END;
'INSERÇÃO EM COD_TURMA E MATRICULA COM EXCEPTION'

ALTER TRIGGER INS_HIS_NOVAALUNO ENABLE;

INSERT INTO HISTORICO(COD_TURMA,MATRICULA,COD_HIST)
VALUES (3,3,3);
 
  CREATE OR REPLACE TRIGGER AUDITORIA_EX
  AFTER INSERT OR UPDATE OR DELETE
  ON NOVAALUNOS
  FOR EACH ROW
  BEGIN
  INSERT INTO TAB_AUDITORIA(USUARIO)
  VALUES(:NEW.NOME_ALUNO);
   DELETE TAB_AUDITORIA
  WHERE USUARIO = :OLD.NOME_ALUNO;
    UPDATE TAB_AUDITORIA
  SET ATUALIZAÇOES = ATUALIZAÇOES + 1;
  END;
  
  
  
SELECT * FROM NOVAALUNOS;
SELECT * FROM TAB_AUDITORIA;



INSERT INTO NOVAALUNOS(NOME_ALUNO)
VALUES ('JOSE S');

ALTER TABLE TAB_AUDITORIA
ADD(HORARIO DATE DEFAULT SYSDATE);

DELETE NOVAALUNOS
WHERE MATRICULA = 10;

UPDATE TAB_AUDITORIA
SET ATUALIZAÇOES  = 1;

DELETE FROM TAB_AUDITORIA
WHERE USUARIO IS NULL;
DELETE FROM TAB_AUDITORIA
WHERE USUARIO = 'ALVARO LEPUS'
OR USUARIO = 'JOSE CARLOS'
OR USUARIO = 'ALINE DIAS'
OR USUARIO = 'MARIA JOSE'
OR USUARIO = 'JOSE A';
  
  INSERT INTO tabelaA SELECT campo1, campo2campoN FROM tabelaB
   










   
   
   
   
   
   
   
  

  



 
    
  
    



            
            






















  

   
       
  







  
  
 

      
      
    
    
  
  

          
          
          
    
    


  


        
        




  
    
  
  
  












  
  









        
        







          
        
    
  

                                                 

 
    
  


  
  

  

      
      
       
          

        
      
      

         
         
          
          
          






                   
        
  
 
 
       

  

       
     
 
  
  
  



        
        
    
      


   
       
       




  

    



	

       
       







  
  
  
  


      
  












      
      
      






























































                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              





                    
                                            








 






















   







 




























 






